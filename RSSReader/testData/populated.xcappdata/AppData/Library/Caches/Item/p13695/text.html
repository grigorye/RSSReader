<?xml version="1.0" encoding="UTF-8"?>
<!doctype html>
<html>
	<head>
		<style type="text/css">
			h2 {
				font: -apple-system-headline;
			}
			body {
				font: -apple-system-body;
				zoom: 1.2;
			}
			img {
				width: auto;
				height : auto;
				max-height: 100%;
				max-width: 100%;
			}
		</style>
	</head>
	<body>
		<h2>Unit Testing Phoenix Controllers with Mox</h2>
		<p>As the ecosystem for <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~elixir-lang.github.io">Elixir</a> matures more and more, there are some libraries that seem particularly promising to me. One of them is <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://github.com/plataformatec/mox">Mox</a>, a simple but powerful library for implementing mocks for predefined behaviours (note the British spelling!). <span></span>José Valim started developing it only a few months ago, but I’ve already found it to be a very useful and flexible tool for writing tests.</p>
 
<p>Because Mox is so new, I haven’t been able to find many tutorials or guides for it. However, since <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://hexdocs.pm/mox/Mox.html#module-example">it’s so easy</a> to set up a basic mock, I though it would be worthwhile to show how I’m using this library for a particular scenario: unit testing <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~phoenixframework.org">Phoenix</a> controllers. I’ll first give an overview of Mox and why it’s appropriate for the task, and then I’ll walk through an actual implementation.</p>
 
<h2>The Benefits of Mox</h2>
 
<p>The philosophy behind Mox can be found in <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts">an article José wrote in 2010</a>. A simple summary is that when it comes to dependency injection, mocks should not be created ad-hoc. Instead, they should be constrained by predefined behaviours. This helps enforce contracts between modules, and it also makes tests easier to maintain and understand.</p>
 
<p>Mox ties mock definitions to specific behaviours. It also requires that any stubbed functions are callbacks for that behaviour. But this library isn’t all about constraints–different implementations of mocks can be run concurrently, which is fantastic for tests. It’s also very easy to customize implementations in each test. Try to keep all of this in mind as you look over the walkthrough below.</p>
 
<h2>Unit Testing a Phoenix Controller</h2>
 
<p>All of the following assumes you’re using Elixir 1.4 and Phoenix 1.3.</p>
 
<ol><li>Run <code>mix phx.new mox-guide</code></li>
 
<li>Add <code>{:mox, "~&gt; 0.3.1"}</code> to <code>mix.exs</code>, and run <code>mix deps.get</code></li>
 
<li>Add a configuration for a service to be used by the controller (which is coming up soon):
 
<pre>
 
<code><span>config :mox_guide,</span>
 
<span>  user_service: MoxGuide.UserService
 
</span></code></pre>
 
<p>Note that we’re not actually going to build this module, but luckily, we don’t need one for a clean compilation!</p></li>
 
<li>Override that config in <code>config/test.exs</code>:
 
<pre><code><span>config :mox_guide,</span>
 
<span>  user_service: MoxGuideWeb.UserServiceMock</span></code></pre>
 
<p>This is the module we’ll be using as a mock.</p></li>
 
<li>Add the following to <code>test_helper.exs</code>:
 
<pre>
 
<code>Mox.defmock(MoxGuideWeb.UserServiceMock, for: MoxGuideWeb.UserServiceBehaviour)</code></pre>
 
</li>
 
<li>Now add an endpoint to <code>router.ex</code> (inside the existing “/” scope):
 
<pre>
 
<code>post "/register", UserController, :register</code></pre>
 
<p>Awesome!</p></li>
 
</ol><p>Now, here are the three new files we need:</p>
 
<h3>user_service_behaviour.ex</h3>
 
<p>First of all, a module that defines the behaviour (I put mine in a directory reserved for service behaviours):</p>
 
<pre>
 
<code>
 
defmodule MoxGuideWeb.UserServiceBehaviour do
 
 @type user :: map
 
 @type error :: :invalid_params
 
 @doc """
 
 Registers a User with information about their credentials, preferences, etc.
 
 """
 
 @callback register_user(user_params :: map) :: {:ok, user} | {:error, error}
 
end
 
</code>
 
</pre>
 
<h3>user_controller.ex</h3>
 
<p>Notice that, for the sake of simplicity, we’re just responding with plain JSON instead of going through a view.</p>
 
<pre>
 
<code>
 
defmodule MoxGuideWeb.UserController do
 
 use MoxGuideWeb, :controller
 
 @user_service Application.get_env(:mox_guide, :user_service)
 
 def register(conn, %{"user" =&gt; _} = params) do
 
  with {:ok, user} &lt;- @user_service.register_user(params) do 
 
   conn 
 
   |&gt; put_status(:ok)
 
   |&gt; json(user)
 
  else
 
   {:error, :missing_param} -&gt;
 
    conn
 
    |&gt; put_status(:unprocessable_entity)
 
    |&gt; json(%{error: "invalid parameters"})
 
   {:error, :invalid_param} -&gt;
 
    conn
 
    |&gt; put_status(:unprocessable_entity)
 
    |&gt; json(%{error: "invalid parameters"})
 
  end
 
 end
 
end
 
</code>
 
</pre>
 
<h3>user_controller_test.ex</h3>
 
<div>
 
<div>
 
<pre>
 
<code>
 
defmodule MoxGuideWeb.UserControllerTest do
 
 useMoxGuideWeb.ConnCase
 
  import Mox
 
  @service_mockMoxGuideWeb.UserServiceMock
 
  setup do
 
   base_params = %{user: %{name: "Chuck Testa"}}
 
   {:ok, params: base_params}
 
  end
 
  describe "REGISTER" do
 
   setup :verify_on_exit!
 
   test "valid parameters yield OK response and body", %{conn: conn, params: params} do
 
    expect(@service_mock, :register_user, fn _ -&gt; {:ok, %{name: "Chuck Testa"}} end)
 
    conn = post conn, user_path(conn, :register), Map.to_list(params)
 
    assert json_response(conn, :ok) == %{"name" =&gt; "Chuck Testa"}
 
   end
 
   test "missing parameters yield 422 with error message", %{conn: conn, params: params} do
 
    expect(@service_mock, :register_user, 2, fn
 
      ^params -&gt;
 
     {:ok, raise "We don't want this function to succeed!"}
 
      _-&gt;
 
     {:error, :invalid_param}
 
    end)
 
    error_resp = %{"error" =&gt; "invalid parameters"}
 
  
 
    # Missing embedded parameter
 
    user_params = put_in(params.user.name, nil)
 
    conn = post conn, user_path(conn, :register), user_params
 
    assert json_response(conn, :unprocessable_entity) == error_resp
 
    # Missing top-level parameter
 
    user_params = put_in(params.user, nil)
 
    conn = post conn, user_path(conn, :register), user_params
 
    assert json_response(conn, :unprocessable_entity) == error_resp
 
   end
 
   test "invalid name yields same response as missing name", %{conn: conn, params: params} do
 
    expect(@service_mock, :register_user, fn _ -&gt; {:error, :invalid_param} end)
 
    conn2 = post conn, user_path(conn, :register), Map.to_list(params)
 
  
 
    expect(@service_mock, :register_user, fn _ -&gt; {:error, :missing_param} end)
 
    conn = post conn, user_path(conn, :register), Map.to_list(params)
 
  
 
    assert response(conn, :unprocessable_entity) == response(conn2, :unprocessable_entity)
 
   end
 
  end
 
 end
 
</code>
 
</pre>
 
</div>
 
<p>Now just run mix test, and everything should pass.</p>
 
</div>
 
<div>
 
<h2>How Mox is Working Here</h2>
 
<p>See how easy the setup on Line 16 of <code>user_controller_test</code> is? Since we really want to test how the controller handles output from the service module, the input into the service module doesn’t matter. In this test, we know exactly what the controller will get back from the service, which lets us easily test out the response data in Line 20.</p>
 
<p>Line 24 shows how to expect a specific number of calls to <code>register_user/2</code>. You can also use <code>stub/3</code> to circumvent any expectation validation. This <code>expect</code> is also a good example of how useful pattern matching is here. There’s one clause for a  “good” call to <code>register_user/2</code> (which we don’t want to call), and one clause for all others. You could even stub a single implementation of <code>register_user/2</code> at the top-level setup macro that just has one clause for each test scenario–that’s what I was doing for a while, but I decided it’s more readable to define expectations within each test.</p>
 
<p>You can also redefine expectations within a test, as on Line 50. While the exact placement of expectations is unfortunately not very strict, multiple definitions are useful if you want the same input (or in this case, any input with arity of 1) to have different outputs throughout the tests. Any calls to <code>register_user/2</code> after the second definition will behave as if the first one never existed.
 
</p></div>
 
<div>
 
<h2>Going Forward</h2>
 
<p>Once again, the best part of Mox is that it’s not only simple and flexible, but it also encourages best practices like explicitness and binding injected dependencies to contracts (i.e. behaviours). There are also a lot of nice tricks that aren’t utilized in the sample test here, such as replacing anonymous functions inside of expectations with references to other functions, like so:</p>
 
<div>
 
<pre><code>expect(@service_mock, :register_user, &amp;some_function/1)</code></pre>
 
</div>
 
<p>This can boost readability and also supports <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">the DRY principle</a>. In addition, Mox has some features to support <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://hexdocs.pm/mox/Mox.html#module-multi-process-collaboration">multi-process collaboration</a>, if your situation requires it.</p>
 
<p>I don’t yet know if Mox would be quite as powerful when testing other types of modules like GenServers, but it’s been a pleasure to use for Phoenix controllers, and it’ll probably remain my go-to library for mocks in Elixir.
 
</p></div>
 
<p>The post <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://spin.atomicobject.com/2017/12/27/elixir-mox-introduction/">Unit Testing Phoenix Controllers with Mox</a> appeared first on <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://spin.atomicobject.com">Atomic Spin</a>.</p>
 
<img height="1" width="1" alt="" style="border:0;float:left;margin:0;padding:0;width:1px;height:1px;" src="https://feeds.feedblitz.com/~/i/513174842/0/atomicspin"><h3 style="clear:left;padding-top:10px;">Related Stories</h3><ul><li><a href="https://spin.atomicobject.com/2017/12/11/javascript-unit-test-mocking/">Mocking in JavaScript Unit Tests Using Sinon.JS</a></li><li><a href="https://spin.atomicobject.com/2017/11/02/property-based-testing-javascript/">An Introduction to Property-Based Testing with JavaScript</a></li><li><a href="https://spin.atomicobject.com/2017/08/07/intro-mocking-moq/">Intro to Mocking with Moq</a></li></ul>
	</body>
</html>
