<?xml version="1.0" encoding="UTF-8"?>
<!doctype html>
<html>
	<head>
		<style type="text/css">
			h2 {
				font: -apple-system-headline;
			}
			body {
				font: -apple-system-body;
				zoom: 1.2;
			}
			img {
				width: auto;
				height : auto;
				max-height: 100%;
				max-width: 100%;
			}
		</style>
	</head>
	<body>
		<h2>CATransaction in Depth</h2>
		<p><a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CATransaction_class/"><code>CATransaction</code></a> is a class that is often overlooked by many iOS developers despite offering many useful functions for controlling and responding to animations. The documentation explains things fairly well, but this post’s goal is to explore <code>CATransaction</code> in depth.</p> 
 
 
 
<ul><li><a href="https://calayer.com/#what-transactions-are">What Transactions Are</a></li> 
  <li><a href="https://calayer.com/#changing-animation-duration">Changing Animation Duration</a></li> 
  <li><a href="https://calayer.com/#changing-animation-timing-function">Changing Animation Timing Function</a></li> 
  <li><a href="https://calayer.com/#preventing-animations-from-occurring">Preventing Animations from Occurring</a></li> 
  <li><a href="https://calayer.com/#getting-notified-when-animations-finish">Getting Notified When Animations Finish</a></li> 
  <li><a href="https://calayer.com/#working-with-locks">Working with Locks</a></li> 
  <li><a href="https://calayer.com/#nesting-transactions">Nesting Transactions</a></li> 
  <li><a href="https://calayer.com/#flushing-transactions">Flushing Transactions</a></li> 
  <li><a href="https://calayer.com/#summary">Summary</a></li> 
</ul><h1>What Transactions Are</h1> 
 
<p>In Core Animation, transactions are a way to group multiple animation-related changes together. Transactions ensure that the desired animation changes are committed to Core Animation at the same time:</p> 
 
<div><div><pre><code><span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
 
<span>backingLayer1</span><span>.</span><span>opacity</span> <span>=</span> <span>1.0</span> 
<span>backingLayer2</span><span>.</span><span>position</span> <span>=</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>50.0</span><span>,</span> <span>y</span><span>:</span> <span>50.0</span><span>)</span> 
<span>backingLayer3</span><span>.</span><span>backgroundColor</span> <span>=</span> <span>UIColor</span><span>.</span><span>red</span><span>.</span><span>cgColor</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Creating a transaction<p>In the trivial example above, no animations will actually occur. The changes made to layers in this way will be reflected immediately.</p> 
 
<p>As the documentation explains, Core Animation has two types of transactions: implicit and explicit. On threads with a run loop (e.g., the main thread), all changes to a layer tree during a run loop cycle will be implicitly placed in a transaction as long as an explicit transaction isn’t already specified. Note that an implicit transaction is <strong>not</strong> created for changes to backing layers.<sup><a href="https://calayer.com/#fn:1">1</a></sup></p> 
 
<p>For standalone layers, explicit transactions aren’t needed to make animated changes:</p> 
 
<div><div><pre><code><span>layer1</span><span>.</span><span>opacity</span> <span>=</span> <span>1.0</span> 
<span>layer2</span><span>.</span><span>position</span> <span>=</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>50.0</span><span>,</span> <span>y</span><span>:</span> <span>50.0</span><span>)</span> 
<span>layer3</span><span>.</span><span>backgroundColor</span> <span>=</span> <span>UIColor</span><span>.</span><span>red</span><span>.</span><span>cgColor</span> 
</code></pre></div>  </div> 
  Implicit transaction involving standalone layers<p>At the beginning of the run loop cycle before that code is executed, Core Animation will have created a transaction implicitly. After running that code, those standalone layer changes will automatically be encoded as animations. At the end of the run loop cycle, Core Animation commits the implicit transaction, and any enqueued animations created within that time are executed.</p> 
 
<p>So now that we know how to create transactions, what can they actually do for us?</p> 
 
<h1>Changing Animation Duration</h1> 
 
<p>Transactions can be used to change the animation duration of every animation involved with that transaction:</p> 
 
<div><div><pre><code><span>layer1</span><span>.</span><span>opacity</span> <span>=</span> <span>1.0</span>	<span>// Default, implicit animation duration</span> 
 
<span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
<span>CATransaction</span><span>.</span><span>setAnimationDuration</span><span>(</span><span>2.0</span><span>)</span> 
 
<span>layer2</span><span>.</span><span>position</span> <span>=</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>50.0</span><span>,</span> <span>y</span><span>:</span> <span>50.0</span><span>)</span>             <span>// Duration: 2.0</span> 
<span>layer3</span><span>.</span><span>backgroundColor</span> <span>=</span> <span>UIColor</span><span>.</span><span>red</span><span>.</span><span>cgColor</span>     <span>// Duration: 2.0</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Changing animation duration using transactions<p><code>layer1</code>’s opacity change will occur with whatever the implicit transaction’s animation duration is. <code>layer2</code>’s and <code>layer3</code>’s respective property changes will occur over the course of 2 seconds, thereby overriding the default implicit animation duration.</p> 
 
<h1>Changing Animation Timing Function</h1> 
 
<p>Transactions can be used to change the animation timing function of every animation involved with that transaction:</p> 
 
<div><div><pre><code><span>layer1</span><span>.</span><span>opacity</span> <span>=</span> <span>1.0</span>    <span>// Uses kCAMediaTimingFunctionDefault</span> 
 
<span>let</span> <span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionLinear</span><span>)</span> 
 
<span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
<span>CATransaction</span><span>.</span><span>setAnimationTimingFunction</span><span>(</span><span>timingFunction</span><span>)</span> 
 
<span>layer2</span><span>.</span><span>position</span> <span>=</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>50.0</span><span>,</span> <span>y</span><span>:</span> <span>50.0</span><span>)</span> 
<span>layer3</span><span>.</span><span>backgroundColor</span> <span>=</span> <span>UIColor</span><span>.</span><span>red</span><span>.</span><span>cgColor</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Changing animation timing function using transactions<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CAMediaTimingFunction_class/"><code>CAMediaTimingFunction</code></a> allows you to specify a cubic Bézier timing function to apply to your animations. You are probably familiar with the standard timing functions used by UIKit, like ease in, ease out, and ease in-ease out. Core Animation supports these same functions via the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CAMediaTimingFunction_class/#//apple_ref/doc/constant_group/Predefined_Timing_Functions">named media timing function constants</a>.</p> 
 
Ease in-ease out Bézier curve<p>The power of <code>CAMediaTimingFunction</code>, however, is that you can specify all the points involved in a cubic Bézier curve to create custom animation timing:</p> 
 
Custom Bézier curve<p>The curve displayed above can be represented as the following media timing function:<sup><a href="https://calayer.com/#fn:2">2</a></sup></p> 
 
<div><div><pre><code><span>let</span> <span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>controlPoints</span><span>:</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.76</span><span>,</span> <span>0.73</span><span>)</span> 
</code></pre></div>  </div> 
<p>One of the most useful ways to apply this type of transaction is to a <code>UIView</code>-style animation function:</p> 
 
<div><div><pre><code><span>let</span> <span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>controlPoints</span><span>:</span> <span>0.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.76</span><span>,</span> <span>0.73</span><span>)</span> 
 
<span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
<span>CATransaction</span><span>.</span><span>setAnimationTimingFunction</span><span>(</span><span>timingFunction</span><span>)</span> 
 
<span>UIView</span><span>.</span><span>animate</span><span>(</span><span>withDuration</span><span>:</span> <span>0.5</span><span>,</span> <span>animations</span><span>:</span> <span>{</span> 
    <span>view1</span><span>.</span><span>alpha</span> <span>=</span> <span>1.0</span> 
<span>})</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Overriding UIView's animation timing function<p><code>UIView</code>-style animation functions support the standard timing functions, but they don’t allow you to specify your own cubic Bézier curve. <code>CATransaction</code> can be used instead to force these animations to use the supplied <code>CAMediaTimingFunction</code> to pace animations.<sup><a href="https://calayer.com/#fn:3">3</a></sup></p> 
 
<p>This is a nice way to leverage the convenience of <code>UIView</code>-style animation functions while still being able to somewhat customize the animation pacing.</p> 
 
<h1>Preventing Animations from Occurring</h1> 
 
<p>Transactions can be used to prevent every animation involved with that transaction from occurring:</p> 
 
<div><div><pre><code><span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
<span>CATransaction</span><span>.</span><span>setDisableActions</span><span>(</span><span>true</span><span>)</span> 
 
<span>UIView</span><span>.</span><span>animate</span><span>(</span><span>withDuration</span><span>:</span> <span>0.5</span><span>,</span> <span>animations</span><span>:</span> <span>{</span> 
    <span>view1</span><span>.</span><span>alpha</span> <span>=</span> <span>1.0</span> 
<span>})</span> 
 
<span>layer2</span><span>.</span><span>position</span> <span>=</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>50.0</span><span>,</span> <span>y</span><span>:</span> <span>50.0</span><span>)</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Preventing animations from being committed using transactions<p>Disabling actions tells Core Animation to simply skip any animated changes to layer properties, so the new values are reflected immediately.<sup><a href="https://calayer.com/#fn:4">4</a></sup></p> 
 
<p>If you recall, standalone layers placed in a layer tree that exists in a run loop-driven thread (i.e., practically every layer you create yourself) may apply implicit animations when certain properties are changed. <em>This is often a source of confusion for some developers who are working directly with layers when unintended animations occur.</em> In order to facilitate immediate changes to these layer properties,<sup><a href="https://calayer.com/#fn:5">5</a></sup> actions must be disabled in a transaction that wraps those changes.</p> 
 
<p>Again, backing layers do not need to have their actions disabled explicitly when making model layer property changes, as <code>UIView</code> handles enabling and disabling actions automatically<sup><a href="https://calayer.com/#fn:6">6</a></sup>, though doing so doesn’t hurt.</p> 
 
<p><code>UIView</code> itself has a handful of functions involved with enabling and disabling animations, such as <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/clm/UIView/setAnimationsEnabled:"><code> 
setAnimationsEnabled(_:)</code></a> and <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/clm/UIView/performWithoutAnimation:"><code> 
performWithoutAnimation(_:)</code></a>. However, to ensure that both <code>UIView</code>-style and <code>CALayer</code>-style animations are suppressed, you can always just use <code>CATransaction</code>.</p> 
 
<p>Occasionally, I find that deep within UIKit, an animation block was created that I wasn’t expecting. While certainly not an ideal solution, if you find unexpected animations are occurring when none of your code could possibly be creating animations, you can attempt to strategically use <code>CATransaction</code> to disable actions temporarily.</p> 
 
<h1>Getting Notified When Animations Finish</h1> 
 
<p>Transactions can be used to notify you when every animation involved with that transaction is finished:</p> 
 
<div><div><pre><code><span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
<span>CATransaction</span><span>.</span><span>setCompletionBlock</span><span>({</span> 
    <span>// Every animation added to this transaction is now finished</span> 
<span>})</span> 
 
<span>UIView</span><span>.</span><span>animate</span><span>(</span><span>withDuration</span><span>:</span> <span>0.5</span><span>,</span> <span>delay</span><span>:</span> <span>0.5</span><span>,</span> <span>options</span><span>:</span> <span>[],</span> <span>animations</span><span>:</span> <span>{</span> 
    <span>view1</span><span>.</span><span>alpha</span> <span>=</span> <span>1.0</span> 
<span>},</span> <span>completion</span><span>:</span> <span>nil</span><span>)</span> 
 
<span>addSeveralLayerAnimations</span><span>()</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Getting notified when a transaction's animations finish<p>This is an incredibly useful capability of <code>CATransaction</code>, and besides disabling actions, it is by far what I personally use <code>CATransaction</code> for the most. Regardless of how complex the timings may be for any number of animations enqueued during the transaction, the completion block will be called only after every animation has finished. In the event that animations are canceled, the completion block will be called at that point.</p> 
 
<p>Note that you must set the completion block <strong>before</strong> creating any animations in that transaction that you want to be tracked for completion.</p> 
 
<p>Regardless of whether the animations involved are <code>CALayer</code> animations or <code>UIView</code> animations,<sup><a href="https://calayer.com/#fn:7">7</a></sup><code>CATransaction</code> will capture and consider all of them to determine the last running animation for calling the completion block. Per the documentation, the completion block will always be called on the main thread.</p> 
 
<p>Another important thing to remember is that <code>CATransaction</code> only considers animations committed directly within the scope of that transaction’s lifecycle. This may seem obvious, but consider the following example:</p> 
 
<div><div><pre><code><span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
<span>CATransaction</span><span>.</span><span>setCompletionBlock</span><span>({</span> 
    <span>// Every animation added to this transaction is now finished</span> 
<span>})</span> 
 
<span>UIView</span><span>.</span><span>animate</span><span>(</span><span>withDuration</span><span>:</span> <span>0.5</span><span>,</span> <span>delay</span><span>:</span> <span>0.5</span><span>,</span> <span>options</span><span>:</span> <span>[],</span> <span>animations</span><span>:</span> <span>{</span> 
    <span>view1</span><span>.</span><span>alpha</span> <span>=</span> <span>1.0</span> 
<span>},</span> <span>completion</span><span>:</span> <span>{</span> <span>finished</span> <span>in</span> 
    <span>self</span><span>.</span><span>addSeveralLayerAnimations</span><span>()</span> 
<span>})</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Transaction completion blocks won't consider animations added later<p>In this example, the transaction’s completion block will be called immediately after the <code>UIView</code> animation completes. Because the animations in <code>addSeveralLayerAnimations()</code> are only added after the first animation finishes, they are not committed during the lifecycle of the transaction. Thus, they are not considered when determining when to call the completion block.</p> 
 
<p>In order to ensure that every animation is accounted for, use delayed animations that are committed immediately rather than waiting to commit zero-delay animations:</p> 
 
<div><div><pre><code><span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
<span>CATransaction</span><span>.</span><span>setCompletionBlock</span><span>({</span> 
    <span>// Every animation added to this transaction is now finished</span> 
<span>})</span> 
 
<span>let</span> <span>animationDuration</span> <span>=</span> <span>0.5</span> 
<span>let</span> <span>animationDelay</span> <span>=</span> <span>0.5</span> 
 
<span>UIView</span><span>.</span><span>animate</span><span>(</span><span>withDuration</span><span>:</span> <span>animationDuration</span><span>,</span> <span>delay</span><span>:</span> <span>animationDelay</span><span>,</span> <span>options</span><span>:</span> <span>[],</span> <span>animations</span><span>:</span> <span>{</span> 
    <span>view1</span><span>.</span><span>alpha</span> <span>=</span> <span>1.0</span> 
<span>},</span> <span>completion</span><span>:</span> <span>nil</span><span>)</span> 
 
<span>let</span> <span>firstAnimationCompletionTime</span> <span>=</span> <span>animationDuration</span> <span>+</span> <span>animationDelay</span> 
 
<span>addSeveralLayerAnimations</span><span>(</span><span>delay</span><span>:</span> <span>firstAnimationCompletionTime</span><span>)</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Committing delayed animations immediately so the transaction captures them<p>If <code>addSeveralLayerAnimations(delay:)</code> ensures that it creates its actual animations immediately—specifying delays appropriately—, then <code>CATransaction</code> will wait for them to complete as well, calling the completion block only after every animation is finished running. This is likely the desired behavior in most scenarios like this.</p> 
 
<h1>Working with Locks</h1> 
 
<p>Transactions can be used to safely modify layer properties in a concurrent environment:</p> 
 
<div><div><pre><code><span>CATransaction</span><span>.</span><span>lock</span><span>()</span> 
 
<span>layer1</span><span>.</span><span>opacity</span> <span>=</span> <span>1.0</span> 
 
<span>CATransaction</span><span>.</span><span>unlock</span><span>()</span> 
</code></pre></div>  </div> 
  Locking transactions for thread safety<p>Core Animation is inherently thread safe, so layer animations and changes to layer trees can occur on any thread. However, if shared layer objects are involved across multiple threads, it’s necessary to use a transaction to lock and unlock access to that data to prevent data corruption. <code>CATransaction</code> locks are recursive, so they’re completely safe to use multiple times in the same thread.</p> 
 
<p>In practice, using transaction locks is almost never necessary. Just keep in mind that if, for some reason, you’re passing layers around to multiple threads and modifying their properties, you should use transaction locks when doing so to ensure data validity.</p> 
 
<h1>Nesting Transactions</h1> 
 
<p>Transactions can be nested:</p> 
 
<div><div><pre><code><span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
<span>CATransaction</span><span>.</span><span>setCompletionBlock</span><span>({</span> 
    <span>// layer1, layer2, and layer3 animations are all finished</span> 
<span>})</span> 
 
<span>layer1</span><span>.</span><span>opacity</span> <span>=</span> <span>1.0</span> 
 
    <span>CATransaction</span><span>.</span><span>begin</span><span>()</span> 
    <span>CATransaction</span><span>.</span><span>setCompletionBlock</span><span>({</span> 
        <span>// layer2 and layer3 animations are all finished</span> 
    <span>})</span> 
 
    <span>layer2</span><span>.</span><span>position</span> <span>=</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>50.0</span><span>,</span> <span>y</span><span>:</span> <span>50.0</span><span>)</span> 
    <span>layer3</span><span>.</span><span>backgroundColor</span> <span>=</span> <span>UIColor</span><span>.</span><span>red</span><span>.</span><span>cgColor</span> 
 
    <span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
 
<span>CATransaction</span><span>.</span><span>commit</span><span>()</span> 
</code></pre></div>  </div> 
  Creating nested transactions<p>In the code above, the outer transaction will consider all three implicit layer animations. The inner transaction will only consider the second and third animations.</p> 
 
<p>In fact, for all iOS applications, an implicit <code>CATransaction</code> is created just before each run loop cycle and committed just after each run loop cycle. So every transaction that we would use in our applications will always be nested inside this run loop transaction.<sup><a href="https://calayer.com/#fn:8">8</a></sup></p> 
 
<p>There is no way for us to know if a transaction is nested within another transaction using public APIs.</p> 
 
<h1>Flushing Transactions</h1> 
 
<p><a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CATransaction_class/#//apple_ref/occ/clm/CATransaction/flush"><code>CATransaction.flush()</code></a> is a mysterious function that has confusing documentation. Someone did a lot of in-depth exploration of what flushing transactions does, and rather than rehash what they discovered, you can <a href="http://optshiftk.com/2013/11/better-documentation-for-catransaction-flush/">read all about it</a> yourself. The gist is that 99.9999% of the time, you will never need to call this function in your working code.</p> 
 
<p>There is a neat trick you can use while breaking in the debugger, though. Because the render server exists outside of your application’s process, being stopped at a break point in your own code doesn’t affect Core Animation rendering at all.<sup><a href="https://calayer.com/#fn:9">9</a></sup> However, if you were to change a <code>UIView</code> or <code>CALayer</code> property while stopped in the debugger, you wouldn’t see any visual changes in your app until you resumed execution. Calling <code>CATransaction.flush()</code>, though, would immediately refresh the display in many cases, without requiring you to resume your application.</p> 
 
<p>Per the description, <code>CATransaction.flush()</code> “flushes any extant implicit transaction.” And, in fact, for every iOS application, there is <strong>always</strong> an extant—i.e., “still existing”—implicit transaction. This is because the implicit, top-level, run-loop transaction is still waiting to be committed.</p> 
 
<h1>Summary</h1> 
 
<p>Core Animation is a complex machine that has a lot of hidden or lesser-known capabilities. <code>CATransaction</code> has a lot of uses, especially if you create complex animations. Being able to override implicit animation durations and timing functions is useful for customizing animation timing. Disabling actions is necessary in some cases, and it guarantees that the changes you make won’t enqueue unexpected animations. Lastly, being able to receive a callback whenever any arbitrary combination of animations is finished is great for controlling your UI’s lifecycle. Of course, any number of these features can be combined into a single transaction, so it’s not necessary to create multiple transactions just to make multiple changes at once.</p> 
 
<p>In later blog posts, we’ll continue to dive more deeply into other useful Core Animation classes.</p> 
 
<div> 
  <ol><li> 
      <p>A backing layer is one that backs a <code>UIView</code> and is created and managed by <code>UIView</code> directly. A standalone layer is one that is created using a <code>CALayer</code> (or subclass) initializer, is added to a layer tree, and is managed by whomever or whatever created it. <a href="https://calayer.com/#fnref:1">↩</a></p> 
    </li> 
    <li> 
      <p>One of the strangest APIs in my opinion, <code>CAMediaTimingFunction</code> takes unnamed control point function parameters instead of naming them or using two <code>CGPoint</code>s instead. This deviates from practically every other Cocoa Touch API naming convention. <a href="https://calayer.com/#fnref:2">↩</a></p> 
    </li> 
    <li> 
      <p>Neither specifying a <code>UIViewAnimationOptions</code> easing curve nor including <code>.OverrideInheritedCurve</code> as an animation option will override the timing function specified by the wrapping <code>CATransaction</code>. <a href="https://calayer.com/#fnref:3">↩</a></p> 
    </li> 
    <li> 
      <p>Technically, disabling actions does just that: prevents <code>CAAction</code>-conforming objects from being created in response to layer property changes. More on <code>CAAction</code> at another time. <a href="https://calayer.com/#fnref:4">↩</a></p> 
    </li> 
    <li> 
      <p>Actually, even when animations are running, the property changes have already occurred immediately in the model layer. It is the presentation layer that is responsible for displaying what we perceive as the animation. <a href="https://calayer.com/#fnref:5">↩</a></p> 
    </li> 
    <li> 
      <p>Specifically, <code>UIView</code> creates no <code>CAAction</code>s for animatable <code>CALayer</code> properties unless those properties are being modified within a UIKit-style animation API. <a href="https://calayer.com/#fnref:6">↩</a></p> 
    </li> 
    <li> 
      <p>In fact, <strong>all</strong> animations created are <code>CALayer</code> animations. <code>UIView</code> ends up creating corresponding layer animations for their animatable properties when changed within an animation block. <a href="https://calayer.com/#fnref:7">↩</a></p> 
    </li> 
    <li> 
      <p>Core Animation is able to efficiently render and synchronize animations to the main thread of your application because it maintains this outermost transaction. By coalescing actions into run loop cycles, application content is only potentially rendered and displayed according to the device’s refresh rate, although flushing transactions can interfere with this. <a href="https://calayer.com/#fnref:8">↩</a></p> 
    </li> 
    <li> 
      <p>To easily see this in practice, add and stop at a break point just after creating a long animation. When running that code, you’ll notice that even though Xcode will stop your application’s main thread, the animation continues to run unimpeded by any of your process’s code. This, again, emphasizes how Core Animation’s architecture does not allow blocking application code to hamper much of the render server’s activities. <a href="https://calayer.com/#fnref:9">↩</a></p> 
    </li> 
  </ol></div>
	</body>
</html>
