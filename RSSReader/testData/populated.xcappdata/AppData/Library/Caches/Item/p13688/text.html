<?xml version="1.0" encoding="UTF-8"?>
<!doctype html>
<html>
	<head>
		<style type="text/css">
			h2 {
				font: -apple-system-headline;
			}
			body {
				font: -apple-system-body;
				zoom: 1.2;
			}
			img {
				width: auto;
				height : auto;
				max-height: 100%;
				max-width: 100%;
			}
		</style>
	</head>
	<body>
		<h2>A hack for fixed-size arrays in Swift</h2>
		<p>Swift 4 doesn‚Äôt have a built-in type for fixed-size, stack-allocated arrays. And as far as I know, implementing such a type in a generic way (for arbitrary array lengths) is currently impossible ‚Äî it would require either special compiler support or more advanced generics features, such as variadic generic parameters.</p> 
 
<h1>Mimicking a fixed-size array with a tuple</h1> 
 
<p>I came across an interesting workaround for this in the standard library source code. The file <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/FixedArray.swift.gyb"><code>FixedArray.swift.gyb</code></a> contains a template for a fixed-size array struct. The struct, named <code>_FixedArrayN&lt;T&gt;</code> (where <code>T</code> is the generic element type and <em>N</em> is the number of array elements), is <strong>a wrapper around a tuple of <em>N</em> elements.</strong></p> 
 
<p>Swift doesn‚Äôt guarantee stack allocation for local variables, but it‚Äôs highly likely that a local variable declared like this will be placed on the stack:</p> 
 
<div><pre><code><span>var</span> <span>eightInts</span> <span>=</span> <span>_FixedArray8</span><span>&lt;</span><span>Int</span><span>&gt;</span><span>(</span><span>allZeros</span><span>:</span> <span>())</span> 
</code></pre></div> 
<p>Contrast this with a regular <code>Array</code>, which is essentially a wrapper around a reference to a separate, heap-allocated buffer. This has many advantages, such as the ability to dynamically grow and shrink the buffer, to outlive the current scope, and to implement copy-on-write (multiple arrays can share the same buffer, as long as no one mutates the buffer). But it comes with some overhead that a simple tuple of <code>N</code> elements doesn‚Äôt have.</p> 
 
<h1>Think twice before using this</h1> 
 
<p>Before I continue, a disclaimer. Here‚Äôs what Michael Ilseman, who added this type to the standard library, has to say:</p> 
 
<blockquote> 
  <p><a href="https://twitter.com/olebegemann/status/939903265751425025">@olebegeman</a> I knew I‚Äôd live to regret adding that!</p> 
  <p>Exercise caution in using it. If mishandled it can balloon code size and the tuple‚Äôs metadata is not cheap.</p> 
  <cite> 
      </cite><p><a href="https://twitter.com/Ilseman">@Ilseman</a></p> 
      <p>Michael Ilseman</p> 
      <p><a href="https://twitter.com/Ilseman/status/940640596754096129">December 12, 2017</a></p> 
   
</blockquote> 
 
<p>I‚Äôm writing about this because I think it‚Äôs an interesting workaround for a real problem, and looking at the implementation is instructive even if you don‚Äôt end up using it in production. Eventually, Swift will hopefully gain a native fixed-size array type (or a low-level function to allocate arbitrary memory on the stack, which would allow you to build the type described here without resorting to code generation).</p> 
 
<h1>Collection interface</h1> 
 
<p>An array type should adopt Swift‚Äôs standard <a href="https://developer.apple.com/documentation/swift/collection"><code>Collection</code></a> protocol. This isn‚Äôt trivial for <code>_FixedArrayN</code> because tuples don‚Äôt support subscripting, i.e. it‚Äôs not straightforward to write code that accesses the <em>n</em>-th element of a tuple (where <em>n</em> is a variable).</p> 
 
<p>The implementation in the standard library solves this with pointer arithmetic on the tuple‚Äôs underlying raw memory. It obtains a pointer to the tuple, computes the byte offset for the <em>n</em>-th element and copies the value from/to that location. Here‚Äôs how <a href="https://github.com/apple/swift/blob/d2dc653420cc5d58e2b0fd3c7e8930613ab515ac/stdlib/public/core/FixedArray.swift.gyb#L63-L93">the <code>subscript</code> implementation looks like</a> (I simplified the code a little):</p> 
 
<div><pre><code><span>internal</span> <span>subscript</span><span>(</span><span>i</span><span>:</span> <span>Int</span><span>)</span> <span>-&gt;</span> <span>T</span> <span>{</span> 
  <span>get</span> <span>{</span> 
    <span>var</span> <span>copy</span> <span>=</span> <span>storage</span> 
    <span>let</span> <span>res</span><span>:</span> <span>T</span> <span>=</span> <span>withUnsafeBytes</span><span>(</span><span>of</span><span>:</span> <span>&amp;</span><span>copy</span><span>)</span> <span>{</span> 
      <span>(</span><span>rawPtr</span> <span>:</span> <span>UnsafeRawBufferPointer</span><span>)</span> <span>-&gt;</span> <span>T</span> <span>in</span> 
      <span>let</span> <span>stride</span> <span>=</span> <span>MemoryLayout</span><span>&lt;</span><span>T</span><span>&gt;.</span><span>stride</span> 
      <span>assert</span><span>(</span><span>rawPtr</span><span>.</span><span>count</span> <span>==</span> <span>$</span><span>{</span><span>N</span><span>}</span><span>*</span><span>stride</span><span>,</span> <span>"layout mismatch?"</span><span>)</span> 
      <span>let</span> <span>bufPtr</span> <span>=</span> <span>UnsafeBufferPointer</span><span>(</span> 
        <span>start</span><span>:</span> <span>rawPtr</span><span>.</span><span>baseAddress</span><span>!.</span><span>assumingMemoryBound</span><span>(</span><span>to</span><span>:</span> <span>T</span><span>.</span><span>self</span><span>),</span> 
        <span>count</span><span>:</span> <span>count</span><span>)</span> 
      <span>return</span> <span>bufPtr</span><span>[</span><span>i</span><span>]</span> 
    <span>}</span> 
    <span>return</span> <span>res</span> 
  <span>}</span> 
  <span>set</span> <span>{</span> <span>/* looks similar */</span> <span>}</span> 
<span>}</span> 
</code></pre></div> 
<p>The <code>${N}</code> is a placeholder for the actual element count that is replaced in the code generation step (see below).</p> 
 
<p>With the subscript in place, it‚Äôs easy to conform the struct to <a href="https://developer.apple.com/documentation/swift/randomaccesscollection"><code>RandomAccessCollection</code></a>. This means you can use it pretty much like a regular array. <code>for</code> loops, <code>map</code>, <code>filter</code>, <code>index(of:)</code>, etc. all work as expected.</p> 
 
<h2>Is it safe?</h2> 
 
<p>You might ask, is operating on the raw memory in this way safe? If you read the code in <a href="https://github.com/apple/swift/blob/d2dc653420cc5d58e2b0fd3c7e8930613ab515ac/stdlib/public/core/FixedArray.swift.gyb#L27-L28"><code>FixedArray.swift.gyb</code></a>, you‚Äôll notice this scary comment:</p> 
 
<div><pre><code><span>// ABI TODO: The [type] has assumptions about tuple layout in the ABI, namely that</span> 
<span>// they are laid out contiguously and individually addressable (i.e. strided).</span> 
</code></pre></div> 
<p>This sounds like the implementation could break with new compiler versions until the ABI is finalized. The person who wrote that comment probably knows this better than I do, but I don‚Äôt think that‚Äôs actually the case. In April 2017, <a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170424/004481.html">John McCall wrote</a>:</p> 
 
<blockquote> 
  <p><strong>Tuples are guaranteed to use a standard C-style layout wherever that layout is ABI-observable, e.g. when you construct an <code>UnsafePointer</code> to one.</strong></p> 
 
  <p>Note that that layout isn‚Äôt ABI-observable when the tuple is, say, just stored in a struct. The compiler is allowed to break up the tuple and store its components however it likes. Of course, if the compiler does that, and you turn around and construct an <code>UnsafePointer</code> to that property, then the compiler has to reconstitute the tuple into an ABI-compliant temporary that it can give you a pointer to; this is yet another reason why you can‚Äôt maintain permanent unsafe pointers to components of a struct.</p> 
</blockquote> 
 
<p>If I interpret this correctly, the call to <a href="https://developer.apple.com/documentation/swift/2635826-withunsafebytes"><code>withUnsafeBytes</code></a> guarantees that the argument (<code>¬©</code>) is laid out contiguously in a way that‚Äôs compatible with a C array of the same size and element type. What <em>isn‚Äôt</em> guaranteed is that this is free of overhead. If the compiler decided to store the tuple in an different layout, it has to make a temporary copy for the duration of the <code>withUsafeBytes</code> call. Depending on the size of the tuple, this might destroy the performance gains we hoped to get from using a stack-allocated value in the first place.</p> 
 
<p>By the way, if you‚Äôre wondering why the subscript getter creates a copy of the tuple first: <code>inout</code> arguments must be mutable, and <code>storage</code> isn‚Äôt (the getter would have to be marked <code>mutating</code> for that).</p> 
 
<h1>Code generation</h1> 
 
<p>Swift doesn‚Äôt support generically-sized tuples, so you‚Äôd need to write a separate type for each array size you need in your code (and these sizes must all be known at compile time). For example, <code>_FixedArray8&lt;T&gt;</code> and <code>_FixedArray16&lt;T&gt;</code> would allow you to use fixed arrays with either 8 or 16 elements (but the element type <code>T</code> can be anything).</p> 
 
<p>Obviously you wouldn‚Äôt want to write these definitions by hand, especially since declaring tuples of the form <code>(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)</code> is no fun. The good news is that the code can be generated. The Swift team uses GYB for this, which is a relatively simple preprocessor they‚Äôve written to keep the standard library source free from excessive repetition (e.g <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Integers.swift.gyb">they use GYB to generate the code for the various integer types</a>).</p> 
 
<p>If you check out <a href="https://github.com/apple/swift/blob/d2dc653420cc5d58e2b0fd3c7e8930613ab515ac/stdlib/public/core/FixedArray.swift.gyb"><code>FixedArray.swift.gyb</code></a>, you‚Äôll notice this at the top:</p> 
 
<div><pre><code>%{ 
  # The sizes to generate code for. 
  sizes = [16] 
}% 
</code></pre></div> 
<p>GYB will generate a <code>_FixedArrayN</code> struct for any size you put in the <code>sizes</code> array here. As you can see, the standard library currently only uses a <code>_FixedArray16</code>.</p> 
 
<h1>Usage</h1> 
 
<p><code>_FixedArrayN</code> is an internal type that the standard library uses in its implementation; it‚Äôs not part of the official standard library API. If you want to use it in your own project, you‚Äôll have to copy the code from the Swift repository:</p> 
 
<ol><li>Download <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/FixedArray.swift.gyb"><code>FixedArray.swift.gyb</code></a> and the <a href="https://github.com/apple/swift/blob/master/utils/gyb.py"><code>gyb.py</code></a> script from the Swift repository. Alternatively, clone the entire repository.</li> 
  <li>Edit <code>FixedArray.swift.gyb</code> to add your desired sizes to the <code>sizes</code> array.</li> 
  <li> 
    <p>Run this command in Terminal:</p> 
 
<div><pre><code><span>&gt;</span> python gyb.py FixedArray.swift.gyb <span>-o</span> FixedArray.swift 
</code></pre></div> 
    <p>This will generate a <code>FixedArray.swift</code> file that you can add to your project.</p> 
  </li> 
</ol><h1>Initializing a fixed-size array</h1> 
 
<p>Swift‚Äôs <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html">strict initialization rules</a> are probably the biggest hurdle when working with <code>_FixedArrayN</code>. A variable must be fully initialized before it can be used; you can‚Äôt create an ‚Äúempty‚Äù fixed-size array with the goal of filling it with data later ‚Äî the compiler won‚Äôt allow it.</p> 
 
<p>Like all structs, <code>_FixedArrayN</code> has a memberwise initializer for its properties, but using that means we‚Äôre back to filling tuples manually ‚Äî exactly the thing we want to avoid.</p> 
 
<p>The standard library implementation also comes with an <code>init(allZeros:)</code> initializer that allows you to set all elements to zero. Here‚Äôs an example:</p> 
 
<div><pre><code><span>var</span> <span>eightInts</span> <span>=</span> <span>_FixedArray8</span><span>&lt;</span><span>Int</span><span>&gt;</span><span>(</span><span>allZeros</span><span>:</span> <span>())</span> 
<span>eightInts</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>42</span> 
<span>print</span><span>(</span><span>eightInts</span><span>)</span> 
<span>// ‚Üí _FixedArray8&lt;Int&gt;(storage: (0, 0, 0, 42, 0, 0, 0, 0))</span> 
</code></pre></div> 
<p>(Note that the initializer takes an empty tuple, or <code>Void</code>, as its argument. The only purpose of the <code>allZeros:</code> parameter is to create a unique name for this initializer ‚Äî the passed-in value isn‚Äôt used.)</p> 
 
<p>This only works with number types, though. If you want to use other types, you‚Äôll need to add one or more other initializers to the GYB file. Here‚Äôs one, <code>init(repeating: T)</code>, that sets all array elements to a value the caller can pass in:</p> 
 
<div><pre><code>extension _FixedArray${N} { 
  internal init(repeating v: T) { 
    self.storage = ( 
% for i in range(0, N-1): 
    v, 
% end 
    v 
    ) 
  } 
} 
</code></pre></div> 
<p>(Check out the GYB syntax for a simple loop: <code>% for i in range(0, N-1):</code>.)</p> 
 
<p>And here‚Äôs how you can use it:</p> 
 
<div><pre><code><span>var</span> <span>fourStrings</span> <span>=</span> <span>_FixedArray4</span><span>(</span><span>repeating</span><span>:</span> <span>""</span><span>)</span> 
<span>fourStrings</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>"ü§î"</span> 
<span>print</span><span>(</span><span>fourStrings</span><span>)</span> 
<span>// ‚Üí _FixedArray4&lt;String&gt;(storage: ("", "ü§î", "", ""))</span> 
 
<span>var</span> <span>fourBools</span> <span>=</span> <span>_FixedArray4</span><span>(</span><span>repeating</span><span>:</span> <span>false</span><span>)</span> 
<span>print</span><span>(</span><span>fourBools</span><span>)</span> 
<span>// ‚Üí _FixedArray4&lt;Bool&gt;(storage: (false, false, false, false))</span> 
</code></pre></div> 
<p>With a little more GYB-fu it should also be possible to write an initializer that takes an array (or an array literal) and copies the elements into the storage tuple one by one.</p> 
<hr><div> 
  <div> 
    <p><strong>If you liked this article, I bet you‚Äôll also like <a href="https://gumroad.com/a/507458675" title="Advanced Swift at objc.io">Advanced Swift</a></strong>, the book I wrote together with Chris Eidhof and Airspeed Velocity. The third edition, fully updated for Swift 4, is out now.</p> 
    <p><a href="https://gumroad.com/a/507458675" title="Advanced Swift at objc.io">Advanced Swift</a> is available as a DRM-free e-book and in print.</p> 
  </div> 
</div>
	</body>
</html>
