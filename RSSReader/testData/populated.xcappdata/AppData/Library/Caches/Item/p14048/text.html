<?xml version="1.0" encoding="UTF-8"?>
<!doctype html>
<html>
	<head>
		<style type="text/css">
			h2 {
				font: -apple-system-headline;
			}
			body {
				font: -apple-system-body;
				zoom: 1.2;
			}
			img {
				width: auto;
				height : auto;
				max-height: 100%;
				max-width: 100%;
			}
		</style>
	</head>
	<body>
		<h2>Make Monkey Patching in Ruby Less Risky with Refinements</h2>
		<p><a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://www.ruby-lang.org/en">Ruby</a> makes it easy to extend its built-in classes, which can be very convenient and lead to more readable code—but it can also be dangerous. This practice, known as “monkey patching,” is common in the Ruby world, and since Ruby 2, it’s been possible to mitigate some of the risks using refinements. <span></span></p>
 
<p>As beneficial as refinements are, they haven’t been embraced as warmly as one might expect. Part of this might have to do with the fact that <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~rubyonrails.org">Rails</a>, home to some of the most extensive monkey patching in the Ruby community, has been slow to adopt them.</p>
 
<h2>Monkey Patching – The Old Way</h2>
 
<p>Monkey patching is useful when you find yourself wishing an existing class had some useful piece of functionality that wasn’t originally built into it. One useful function that Ruby’s String class doesn’t provide by default is ‘titleize’, which takes a string and capitalizes the first letter of each word.</p>
 
<p>It’s easy enough to make a function that will titleize a string, then put it in a module with some helpers and import it when you want to use it, but that isn’t very OO. If you open the class and add the method to the class definition itself, it’s as easy as calling the method on any string.</p>
 
<pre><code>
 
"moby dick".titleize # -&gt; Moby Dick
 
</code></pre>
 
<p>In Ruby, you can open a class at any time by writing a class definition.</p>
 
<pre><code>
 
class String
 
  def titleize
 
    # your implementation here
 
  end
 
end
 
</code></pre>
 
<p>If the class you name doesn’t exist, it is created. If it does exist, it is opened. When it’s open, any definitions you make inside will be available to all instances of the class. If the definition you make inside already exists on the class, the old definition will be wiped out and replaced with yours.</p>
 
<h2>Pitfalls</h2>
 
<p>If you’ve always used Ruby with Rails, you might be thinking that titleize already exists in the String class. That’s because Rails makes it available. However, if you’ve never used Ruby with Rails, you might not have even known that titleize is a thing. This is the first problem with monkey patching; everyone has inconsistent ideas about what’s included with the standard library.</p>
 
<p>Worse than this, though, is the risk of accidentally overriding a method that already exists. It can lead to mysterious errors in other parts of your codebase, or even in libraries.</p>
 
<p>Maybe your application needs a titleize function to randomly slap titles onto the beginning and end of a string:</p>
 
<pre><code>
 
"Judi Dench".titleize # "Dame Judi Dench CH, DBE, FRSA"
 
</code></pre>
 
<p>When you plug your code into a Rails application, things suddenly don’t work as intended. Other libraries start breaking, and you start seeing titles appear in other parts of your application.</p>
 
<pre><code>
 
"moby dick".titleize # "Sir Moby Dick Esq. KBE"
 
</code></pre>
 
<p>Even if you’re positive that the method name you’re using is unique, you can still run into issues. Maybe you monkey-patch a unique method into a class and then later, you add a library that monkey-patches the same method into the same class. The implementation might differ enough that it breaks your existing code.</p>
 
<h2>Enter Refinements</h2>
 
<p>With refinements, it’s possible to monkey-patch existing classes without polluting the class globally. Your refinement will live in a module that you will use in places where you want the modified behavior.</p>
 
<pre><code>
 
module M
 
  refine String do
 
    def titleize
 
      # Implementation
 
    end
 
  end
 
end
 
</code></pre>
 
<p>Then, in your code, you just need to write `using M`. In the scope of that `using` statement, any calls to titleize will use your custom version. Outside the scope of `using`, it will use the original version.</p>
 
<p>Monkey-patching this way allows you to opt into custom behavior without having it leak out into other parts of your application. Even though the Ruby community as a whole has been slow to adopt this method, it’s worth working into your own code when you find yourself wanting to monkey-patch an existing class.</p>
 
<p>The post <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://spin.atomicobject.com/2017/12/29/monkey-patching-refinements/">Make Monkey Patching in Ruby Less Risky with Refinements</a> appeared first on <a href="http://feeds.feedblitz.com/~/t/0/0/atomicspin/~https://spin.atomicobject.com">Atomic Spin</a>.</p>
 
<img height="1" width="1" alt="" style="border:0;float:left;margin:0;padding:0;width:1px;height:1px;" src="https://feeds.feedblitz.com/~/i/513628478/0/atomicspin"><h3 style="clear:left;padding-top:10px;">Related Stories</h3><ul><li><a href="https://spin.atomicobject.com/2017/12/15/phoenix-framework-support-rails/">Phoenix Framework Support and Why Ruby on Rails Still Works</a></li><li><a href="https://spin.atomicobject.com/2017/10/03/rails-ember-cli-front-end/">Data with Rails and Ember CLI, Part 2: Building the Front End</a></li><li><a href="https://spin.atomicobject.com/2017/10/02/rails-ember-cli-data-api/">Data with Rails and Ember CLI, Part 1: Setting up the API</a></li></ul>
	</body>
</html>
