<?xml version="1.0" encoding="UTF-8"?>
<!doctype html>
<html>
	<head>
		<style type="text/css">
			h2 {
				font: -apple-system-headline;
			}
			body {
				font: -apple-system-body;
				zoom: 1.2;
			}
			img {
				width: auto;
				height : auto;
				max-height: 100%;
				max-width: 100%;
			}
		</style>
	</head>
	<body>
		<h2>How to import a C library in Swift using the Swift Package Manager</h2>
		<p><em>This is an excerpt from the <em>Interoperability</em> chapter in our book <a href="https://gumroad.com/a/507458675" title="objc.io: Advanced Swift"><em>Advanced Swift</em></a>. The new edition, revised and extended for Swift 4, is out now.</em></p> 
 
<hr><p>Swift is great at interoperating with C code, but the initial step of importing a C library such that the Swift compiler can see the C declarations can be quite tricky. This is a step-by-step tutorial how to do this using the <a href="https://swift.org/package-manager/">Swift Package Manager</a>.</p> 
 
<p>We’ll use the <a href="https://github.com/commonmark/cmark">cmark library</a> as an example. cmark is a reference implementation of <a href="http://commonmark.org/">CommonMark</a>, a strongly defined <a href="https://daringfireball.net/projects/markdown/syntax">Markdown</a> specification.</p> 
 
<h1>1. Installing cmark</h1> 
 
<p>The first step is to install the <a href="https://github.com/commonmark/cmark">cmark library</a>. We use <a href="https://brew.sh">Homebrew</a> as our package manager on macOS to do this. Type this command in Terminal:</p> 
 
<div><pre><code>brew install cmark 
</code></pre></div> 
<p>At the time of writing, cmark 0.28.3 was the most recent version.</p> 
 
<h1>2. Wrapping cmark in a module</h1> 
 
<p>In C, you’d now <code>#include</code> one or more of the library’s header files to make their declarations visible to your own code. Swift can’t handle C header files directly; it expects dependencies to be <em>modules</em>. For a C or Objective-C library to be visible to the Swift compiler, the library must provide a <em>module map</em> in the <a href="https://clang.llvm.org/docs/Modules.html">Clang modules</a> format. Among other things, the module map lists the header files that make up the module.</p> 
 
<p>Since cmark doesn’t come with a module map, your next task is to make one. You’ll create a package for the Swift Package Manager that won’t contain any code; its only purpose is to act as the module wrapper for the cmark library.</p> 
 
<h2>2a. Create a SwiftPM package</h2> 
 
<p>Create a directory for the package and then run <code>swift package init</code>, telling the package manager to create the scaffolding for a <em>system module</em>:</p> 
 
<div><pre><code>mkdir Ccmark 
<span>cd </span>Ccmark 
swift package init <span>--type</span> system-module 
</code></pre></div> 
<p>In SwiftPM lingo, <em>system packages</em> are libraries installed by systemwide package managers, such as Homebrew, or APT on Linux. A system module is any SwiftPM package that refers to such a library. By convention, the names of pure wrapper modules such as this should be prefixed with <code>C</code>.</p> 
 
<h2>2b. Edit the package manifest</h2> 
 
<p>Next, edit the generated <code>Package.swift</code> file to look like this:</p> 
 
<div><pre><code><span>// swift-tools-version:4.0</span> 
<span>import</span> <span>PackageDescription</span> 
 
<span>let</span> <span>package</span> <span>=</span> <span>Package</span><span>(</span> 
    <span>name</span><span>:</span> <span>"Ccmark"</span><span>,</span> 
    <span>pkgConfig</span><span>:</span> <span>"libcmark"</span><span>,</span> 
    <span>providers</span><span>:</span> <span>[</span> 
        <span>.</span><span>brew</span><span>([</span><span>"cmark"</span><span>])</span> 
    <span>]</span> 
<span>)</span> 
</code></pre></div> 
<p>The <code>pkgConfig</code> parameter specifies the name of the <a href="https://en.wikipedia.org/wiki/Pkg-config">pkg-config</a> file where SwiftPM can find the header and library search paths for the imported library. You can run the <code>pkg-config</code> tool to check what values SwiftPM will see. On my machine the output looks like this:</p> 
 
<div><pre><code>pkg-config libcmark <span>--libs</span> <span>--cflags</span> 
<span># -I/usr/local/Cellar/cmark/0.28.3/include</span> 
<span># -L/usr/local/Cellar/cmark/0.28.3/lib -lcmark</span> 
</code></pre></div> 
<p>The <code>providers</code> directive is optional. It’s an installation hint the package manager can display to the user when the target library isn’t installed.</p> 
 
<h2>2c. Create a C shim header</h2> 
 
<p>Before you can edit the module map, create a C header file named <code>shim.h</code>. It should contain only the following line:</p> 
 
<div><pre><code><span>#include &lt;cmark.h&gt; 
</span></code></pre></div> 
<h2>2d. Write the module map</h2> 
 
<p>Now you can create the <code>module.modulemap</code> file in the root directory of the Ccmark package. It should look like this:</p> 
 
<div><pre><code>module Ccmark [system] { 
    header "shim.h" 
    link "cmark" 
    export * 
} 
</code></pre></div> 
<p>The shim header works around the limitation that module maps must contain absolute or local paths. Alternatively, you could’ve omitted the shim and specified the cmark header directly in the module map, as in <code>header "/usr/local/Cellar/cmark/0.28.3/include/cmark.h"</code>. But then the path of <code>cmark.h</code> would be hardcoded into the module map. With the shim, the package manager reads the correct header search path from the pkg-config file and adds it to the compiler invocation.</p> 
 
<h2>2e. Create a Git repository</h2> 
 
<p>The final step for the Ccmark package is to commit everything to a Git repository:</p> 
 
<div><pre><code>git init 
git add <span>.</span> 
git commit <span>-m</span> <span>"Initial commit"</span> 
</code></pre></div> 
<p>This is necessary because you’ll now create a second package which imports <code>Ccmark</code>, and the package manager requires a Git branch or tag name for each dependency.</p> 
 
<h1>3. Creating the client module</h1> 
 
<h2>3a. Another SwiftPM package</h2> 
 
<p>Create another directory on the same level as the <code>Ccmark</code> directory and run <code>swift package init</code> once more, this time for an executable:</p> 
 
<div><pre><code><span>cd</span> .. 
mkdir CommonMarkExample 
<span>cd </span>CommonMarkExample 
swift package init <span>--type</span> executable 
</code></pre></div> 
<p>You’ll need to add the <code>Ccmark</code> dependency to the package manifest. Edit <code>Package.swift</code> to look like this:</p> 
 
<div><pre><code><span>// swift-tools-version:4.0</span> 
<span>import</span> <span>PackageDescription</span> 
 
<span>let</span> <span>package</span> <span>=</span> <span>Package</span><span>(</span> 
    <span>name</span><span>:</span> <span>"CommonMarkExample"</span><span>,</span> 
    <span>dependencies</span><span>:</span> <span>[</span> 
        <span>.</span><span>package</span><span>(</span><span>url</span><span>:</span> <span>"../Ccmark"</span><span>,</span> <span>.</span><span>branch</span><span>(</span><span>"master"</span><span>)),</span> 
    <span>],</span> 
    <span>targets</span><span>:</span> <span>[</span> 
        <span>.</span><span>target</span><span>(</span> 
            <span>name</span><span>:</span> <span>"CommonMarkExample"</span><span>,</span> 
            <span>dependencies</span><span>:</span> <span>[]),</span> 
    <span>]</span> 
<span>)</span> 
</code></pre></div> 
<p>Notice that we’re using a relative file system path to refer to <code>Ccmark</code>. If you want to make this accessible to other team members, push the <code>Ccmark</code> repository to a server and replace its URL here.</p> 
 
<h2>3b. Test if it works</h2> 
 
<p>Now you should be able to <code>import Ccmark</code> and call any cmark API. Add the following snippet to <code>main.swift</code> for a quick test to see if everything works:</p> 
 
<div><pre><code><span>import</span> <span>Ccmark</span> 
 
<span>let</span> <span>markdown</span> <span>=</span> <span>"*Hello World*"</span> 
<span>let</span> <span>cString</span> <span>=</span> <span>cmark_markdown_to_html</span><span>(</span><span>markdown</span><span>,</span> <span>markdown</span><span>.</span><span>utf8</span><span>.</span><span>count</span><span>,</span> <span>0</span><span>)</span><span>!</span> 
<span>defer</span> <span>{</span> 
    <span>free</span><span>(</span><span>cString</span><span>)</span> 
<span>}</span> 
<span>let</span> <span>html</span> <span>=</span> <span>String</span><span>(</span><span>cString</span><span>:</span> <span>cString</span><span>)</span> 
<span>print</span><span>(</span><span>html</span><span>)</span> 
</code></pre></div> 
<p>The <a href="https://github.com/commonmark/cmark/blob/5c2f3341e3c129aeb27f70fe6ca9ed0fea8f2383/src/cmark.h#L22-L28"><code>cmark_markdown_to_html</code></a> function takes a Markdown string and converts it to HTML.</p> 
 
<p>Back in Terminal, run the program:</p> 
 
<div><pre><code>swift run 
<span># &lt;p&gt;&lt;em&gt;Hello World&lt;/em&gt;&lt;/p&gt;</span> 
</code></pre></div> 
<p>If you see HTML as the output, you just successfully called a C function from Swift!</p> 
 
<hr><p><em>If you liked this excerpt, consider <a href="https://gumroad.com/a/507458675" title="objc.io: Advanced Swift">purchasing the full book</a>. Thanks!</em></p> 
 
<p><em>In the book, we show how you can write a Swift wrapper for the cmark library that allows you to use the library’s features from Swift without ever having to deal with unsafe and/or inconvenient C constructs like pointers. The public API feels like 100% idiomatic Swift, without having to reimplement the CommonMark spec from scratch. You can check out <a href="https://github.com/objcio/commonmark-swift">the code for the wrapper library on GitHub</a>.</em></p>
	</body>
</html>
