<?xml version="1.0" encoding="UTF-8"?>
<!doctype html>
<html>
	<head>
		<style type="text/css">
			h2 {
				font: -apple-system-headline;
			}
			body {
				font: -apple-system-body;
				zoom: 1.2;
			}
			img {
				width: auto;
				height : auto;
				max-height: 100%;
				max-width: 100%;
			}
		</style>
	</head>
	<body>
		<h2>CAShapeLayer in Depth, Part II</h2>
		<p><a href="http://calayer.com/core-animation/2016/05/22/cashapelayer-in-depth.html">In “CAShapeLayer in Depth, Part I,”</a> we explored the creation and configuration of shape layers, looking at each of their properties in turn. While useful as a static shape drawing tool, <code>CAShapeLayer</code> was built to be a powerful, easy-to-use animation class as well. Now, in Part II of “CAShapeLayer in Depth,” we’ll take a close look at each of <code>CAShapeLayer</code>’s animatable properties.</p> 
 
 
 
<p>The primary advantage of using shape layers for animation in place of using something like Core Graphics is that <code>CAShapeLayer</code> is composited on the GPU, making it significantly faster. In fact, like practically every Core Animation animation, once a shape layer animation is committed from the main thread of an application, Core Animation does all the heavy lifting inside its own processes, leaving an application’s main thread completely free during the animation. Animating with Core Graphics, on the other hand, might require an application to render a bitmap for every frame of the animation, sending each bitmap to Core Animation to composite along with the rest of the layer hierarchy.<sup><a href="http://calayer.com/#fn:1">1</a></sup></p> 
 
<p>As a reminder, Part II of this series will be focused on the basics of shape layer animating. Each example will be as simple as possible in order to clearly demonstrate the effects of animating each property. In the last part of this series, Part III, we’ll look at a few examples of non-trivial, real-world applications of shape layers.</p> 
 
<ul><li><a href="http://calayer.com/#animatable-properties">Animatable Properties</a>    <ul><li><a href="http://calayer.com/#path">Path</a></li> 
      <li><a href="http://calayer.com/#fill-color">Fill Color</a></li> 
      <li><a href="http://calayer.com/#line-dash-phase">Line Dash Phase</a></li> 
      <li><a href="http://calayer.com/#line-width">Line Width</a></li> 
      <li><a href="http://calayer.com/#miter-limit">Miter Limit</a></li> 
      <li><a href="http://calayer.com/#stroke-color">Stroke Color</a></li> 
      <li><a href="http://calayer.com/#stroke-start-and-end">Stroke Start and End</a></li> 
    </ul></li> 
  <li><a href="http://calayer.com/#summary">Summary</a></li> 
</ul><h1>Animatable Properties</h1> 
 
<p>A little over half of <code>CAShapeLayer</code>’s properties are animatable: <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/#//apple_ref/occ/instp/CAShapeLayer/path"><code>path</code></a>, <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/#//apple_ref/occ/instp/CAShapeLayer/fillColor"><code>fillColor</code></a>, <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/#//apple_ref/occ/instp/CAShapeLayer/lineDashPhase"><code>lineDashPhase</code></a>, <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/#//apple_ref/occ/instp/CAShapeLayer/lineWidth"><code>lineWidth</code></a>, <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/#//apple_ref/occ/instp/CAShapeLayer/miterLimit"><code>miterLimit</code></a>, <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/#//apple_ref/occ/instp/CAShapeLayer/strokeColor"><code>strokeColor</code></a>, <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/#//apple_ref/occ/instp/CAShapeLayer/strokeStart"><code>strokeStart</code></a>, and <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/#//apple_ref/occ/instp/CAShapeLayer/strokeEnd"><code>strokeEnd</code></a>.</p> 
 
<h2>Path</h2> 
 
<p>Path animations are by far the most powerful and most complex aspects of <code>CAShapeLayer</code>. Path animations allow you to morph a shape layer from one shape to another, which can create very compelling UI effects if used carefully. <code>CAShapeLayer</code> has the following to say about animations on the <code>path</code> property:</p> 
 
<blockquote> 
  <p>Paths will interpolate as a linear blend of the “on-line” points; “off-line” points may be interpolated non-linearly (e.g. to preserve continuity of the curve’s derivative).</p> 
</blockquote> 
 
<p>What this means is that “on-line” points—those that are explicitly specified as part of a path’s description—are interpolated by moving them in a straight line from their starting positions to their ending positions. On the other hand, “off-line” points—those that are calculated or inferred as intermediary points between “on-line” points—are potentially interpolated using more complex means, the details of which are not made available to us.</p> 
 
Animating between two different paths<p>Here’s the code that produces this animation:</p> 
 
<div><div><pre><code><span>let</span> <span>starPath</span> <span>=</span> <span>UIBezierPath</span><span>()</span> 
<span>starPath</span><span>.</span><span>move</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>81.5</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>101.07</span><span>,</span> <span>y</span><span>:</span> <span>63.86</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>163.0</span><span>,</span> <span>y</span><span>:</span> <span>64.29</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>113.16</span><span>,</span> <span>y</span><span>:</span> <span>99.87</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>131.87</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>81.5</span><span>,</span> <span>y</span><span>:</span> <span>122.13</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>31.13</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>49.84</span><span>,</span> <span>y</span><span>:</span> <span>99.87</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>0.0</span><span>,</span> <span>y</span><span>:</span> <span>64.29</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>61.93</span><span>,</span> <span>y</span><span>:</span> <span>63.86</span><span>))</span> 
<span>starPath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>81.5</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
 
<span>let</span> <span>rectanglePath</span> <span>=</span> <span>UIBezierPath</span><span>()</span> 
<span>rectanglePath</span><span>.</span><span>move</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>81.5</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>163.0</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>163.0</span><span>,</span> <span>y</span><span>:</span> <span>82.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>163.0</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>163.0</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>82.0</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>0.0</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>0.0</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>0.0</span><span>,</span> <span>y</span><span>:</span> <span>82.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>0.0</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
<span>rectanglePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>81.5</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
 
<span>// Set an initial path</span> 
<span>shapeLayer</span><span>.</span><span>path</span> <span>=</span> <span>starPath</span><span>.</span><span>cgPath</span> 
 
<span>let</span> <span>pathAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"path"</span><span>)</span> 
<span>pathAnimation</span><span>.</span><span>toValue</span> <span>=</span> <span>rectanglePath</span><span>.</span><span>cgPath</span> 
<span>pathAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>0.75</span> 
<span>pathAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionEaseInEaseOut</span><span>)</span> 
<span>pathAnimation</span><span>.</span><span>autoreverses</span> <span>=</span> <span>true</span> 
<span>pathAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>pathAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"pathAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
  Animating a shape layer's path<p>It’s pretty obvious that the animation itself is trivial: all it needs is another <code>CGPath</code> to animate to. The hard part is constructing the right paths so the animation looks appealing. Now consider what happens when we simplify the rectangle path; after all, a rectangle can easily be represented by a path with only four unique points:<sup><a href="http://calayer.com/#fn:2">2</a></sup></p> 
 
<div><div><pre><code><span>let</span> <span>squarePath</span> <span>=</span> <span>UIBezierPath</span><span>()</span> 
<span>squarePath</span><span>.</span><span>move</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>0.0</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
<span>squarePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>163.0</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
<span>squarePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>163.0</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>squarePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>0.0</span><span>,</span> <span>y</span><span>:</span> <span>157.0</span><span>))</span> 
<span>squarePath</span><span>.</span><span>addLine</span><span>(</span><span>to</span><span>:</span> <span>CGPoint</span><span>(</span><span>x</span><span>:</span> <span>0.0</span><span>,</span> <span>y</span><span>:</span> <span>7.0</span><span>))</span> 
</code></pre></div>  </div> 
<p>And here’s what animating to that path might look like:<sup><a href="http://calayer.com/#fn:3">3</a></sup></p> 
 
Animating to a path with a differing number of segments<p>This will almost always result in an undesirable animation. Per the documentation for <code>CAShapeLayer</code>’s <a href="https://developer.apple.com/documentation/quartzcore/cashapelayer/1521904-path"><code>path</code> property</a>, the result of a path animation is undefined<sup><a href="http://calayer.com/#fn:4">4</a></sup> if the path being animated to has a different number of control points or segments. In this case, the second path has fewer line segments, so Core Animation actually doesn’t know what to do with the remaining line segments from the original path.<sup><a href="http://calayer.com/#fn:5">5</a></sup></p> 
 
<p>As a general rule of thumb, your initial and animatable paths should always contain the same number of points. To make this easier while designing your shapes<sup><a href="http://calayer.com/#fn:6">6</a></sup>, start with the more complex path—the one with the most points or segments—involved with an animation. From there, move the points around to create the simpler shape, placing redundant points wherever they might naturally resolve in a path morphing animation.</p> 
 
<h2>Fill Color</h2> 
 
<p>Animating a shape’s fill color is straightforward:</p> 
 
<div><div><pre><code><span>shapeLayer</span><span>.</span><span>fillColor</span> <span>=</span> <span>UIColor</span><span>.</span><span>red</span><span>.</span><span>cgColor</span> 
 
<span>let</span> <span>fillColorAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"fillColor"</span><span>)</span> 
<span>fillColorAnimation</span><span>.</span><span>toValue</span> <span>=</span> <span>UIColor</span><span>.</span><span>cyan</span><span>.</span><span>cgColor</span> 
<span>fillColorAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>0.75</span> 
<span>fillColorAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionEaseInEaseOut</span><span>)</span> 
<span>fillColorAnimation</span><span>.</span><span>autoreverses</span> <span>=</span> <span>true</span> 
<span>fillColorAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>fillColorAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"fillColorAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
Animating a shape layer's fill color<p>One thing to keep in mind is that Core Animation always interpolates color in the RGB color space, which is unfortunate but completely understandable given the complexity of converting to better color spaces. RGB is strictly a technical color space used by computers because of the way pixels display color, so the straight line between points when linearly interpolating between two colors in an RGB color cube can pass through arbitrary colors. In the above example, you can see that the fill color appears to transition from red to dark gray to cyan. A better color space can interpolate between hue or luminosity, for example, which might create more visual continuity according to how we perceive color; however, even with a color space like HSB, the results may not look that great with a straight linear interpolation.</p> 
 
<p>It turns out that interpolating between two colors in a way that is visually pleasing to the human eye <a href="https://www.alanzucconi.com/2016/01/06/colour-interpolation/">can be hard</a> and computationally expensive, especially for real-time rendering, but it can be done. For practical purposes, if a straight RGB interpolation between two colors doesn’t produce acceptable results, you may instead choose to use a keyframe animation, picking a handful of better in-between colors.</p> 
 
<p>Finally, recall in Part I that <code>UIColor</code> can create a pattern image fill. There’s nothing inherently unique about pattern images versus solid color fills, so you can, of course, animate to or from a pattern image as well.</p> 
 
<h2>Line Dash Phase</h2> 
 
<p>Line dash phase, or dash offset, is how far into the dash pattern the line actually starts. Animating this property gives you the “marching ants” effect:</p> 
 
<div><div><pre><code><span>shapeLayer</span><span>.</span><span>lineDashPattern</span> <span>=</span> <span>[</span><span>5</span><span>]</span> 
 
<span>let</span> <span>lineDashPhaseAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"lineDashPhase"</span><span>)</span> 
<span>lineDashPhaseAnimation</span><span>.</span><span>byValue</span> <span>=</span> <span>10.0</span> 
<span>lineDashPhaseAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>0.75</span> 
<span>lineDashPhaseAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionLinear</span><span>)</span> 
<span>lineDashPhaseAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>lineDashPhaseAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"lineDashPhaseAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
Animating a shape layer's line dash phase<p>To ensure that a dash phase animation loops seamlessly, the animation value should be twice the dash phase pattern if there’s only one element in the array and the sum of the elements otherwise.<sup><a href="http://calayer.com/#fn:7">7</a></sup></p> 
 
<div><div><pre><code><span>let</span> <span>dashPattern</span> <span>=</span> <span>[</span><span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>]</span> 
<span>let</span> <span>dashPhase</span> <span>=</span> <span>dashPattern</span><span>?</span><span>.</span><span>map</span><span>(</span> <span>{</span> <span>return</span> <span>$0</span><span>.</span><span>floatValue</span> <span>}</span> <span>)</span><span>.</span><span>reduce</span><span>(</span><span>0</span><span>,</span> <span>{</span> <span>$0</span> <span>+</span> <span>$1</span> <span>})</span> 
 
<span>shapeLayer</span><span>.</span><span>lineDashPattern</span> <span>=</span> <span>dashPattern</span> 
 
<span>let</span> <span>lineDashPhaseAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"lineDashPhase"</span><span>)</span> 
<span>lineDashPhaseAnimation</span><span>.</span><span>byValue</span> <span>=</span> <span>dashPhase</span> 
<span>lineDashPhaseAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>0.75</span> 
<span>lineDashPhaseAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionLinear</span><span>)</span> 
<span>lineDashPhaseAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>lineDashPhaseAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"lineDashPhaseAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
Ensuring a seamless line dash phase animation<p>Though the dash phase animation is seamless, you will often see a seam at the start of the line itself. If the sum of the dash pattern array (or twice its value if there is only one element) does not evenly divide the total unit length of the shape’s path, there will be a discontinuity that can create a noticeable seam. There is no built-in method for determining the length of an arbitrary path, and the <a href="https://github.com/louisdh/bezierpath-length/blob/master/calculations.md">process of doing so is not trivial</a>. Fortunately, there appears to be <a href="https://github.com/louisdh/bezierpath-length">an open source solution</a> available specifically for <code>CGPath</code>s. In practice, for non-programmatically generated shape paths, it’s often easy enough to tweak the dash pattern until it repeats evenly.</p> 
 
<h2>Line Width</h2> 
 
<p>Line width is another straightforward property to animate:</p> 
 
<div><div><pre><code><span>shapeLayer</span><span>.</span><span>lineWidth</span> <span>=</span> <span>0.0</span> 
 
<span>let</span> <span>lineWidthAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"lineWidth"</span><span>)</span> 
<span>lineWidthAnimation</span><span>.</span><span>toValue</span> <span>=</span> <span>10.0</span> 
<span>lineWidthAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>1.5</span> 
<span>lineWidthAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionEaseInEaseOut</span><span>)</span> 
<span>lineWidthAnimation</span><span>.</span><span>autoreverses</span> <span>=</span> <span>true</span> 
<span>lineWidthAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>lineWidthAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"lineWidthAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
Animating a shape layer's line width<p>Recall that path strokes straddle the bounds of the path itself, so half the line width will be inside the path and half will be outside.</p> 
 
<h2>Miter Limit</h2> 
 
<p>Among all the animatable properties, miter limit is the most perplexing. Briefly, miter limit determines when a miter-style line join switches to a bevel join instead. And while Core Animation does support <code>miterLimit</code> as an animatable property, it actually performs no animation at all. The change to pertinent line joins happens immediately, making it a seemingly-useless property to animate. All that comes to mind is using a miter limit animation in conjunction with other shape layer animations to switch how certain lines are joined mid-animation.</p> 
 
<div><div><pre><code><span>shapeLayer</span><span>.</span><span>miterLimit</span> <span>=</span> <span>10.0</span> 
 
<span>let</span> <span>miterLimitAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"miterLimit"</span><span>)</span> 
<span>miterLimitAnimation</span><span>.</span><span>toValue</span> <span>=</span> <span>0.0</span> 
<span>miterLimitAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>0.75</span> 
<span>miterLimitAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionEaseInEaseOut</span><span>)</span> 
<span>miterLimitAnimation</span><span>.</span><span>autoreverses</span> <span>=</span> <span>true</span> 
<span>miterLimitAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>miterLimitAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"miterLimitAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
"Animating" a shape layer's miter limit<h2>Stroke Color</h2> 
 
<p>Similar to <a href="http://calayer.com/#fill-color">fill color</a>, animating stroke color is easy:</p> 
 
<div><div><pre><code><span>shapeLayer</span><span>.</span><span>strokeColor</span> <span>=</span> <span>UIColor</span><span>.</span><span>red</span><span>.</span><span>cgColor</span> 
 
<span>let</span> <span>strokeColorAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"strokeColor"</span><span>)</span> 
<span>strokeColorAnimation</span><span>.</span><span>toValue</span> <span>=</span> <span>UIColor</span><span>.</span><span>cyan</span><span>.</span><span>cgColor</span> 
<span>strokeColorAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>0.75</span> 
<span>strokeColorAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionEaseInEaseOut</span><span>)</span> 
<span>strokeColorAnimation</span><span>.</span><span>autoreverses</span> <span>=</span> <span>true</span> 
<span>strokeColorAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>strokeColorAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"strokeColorAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
Animating a shape layer's stroke color<h2>Stroke Start and End</h2> 
 
<p>A very useful pair of animatable properties is <code>strokeStart</code> and <code>strokeEnd</code>. Both represent a relative point along the total path length, defined as a fraction between 0.0 and 1.0, where 0.0 indicates the beginning of the path, and 1.0 indicates the end of the path. The visible portion of the path is always the difference between <code>strokeEnd</code> and <code>strokeStart</code>.</p> 
 
<p>Animating <code>strokeEnd</code> from 0.0 to 1.0 is commonly used to “draw on” a path:</p> 
 
<div><div><pre><code><span>shapeLayer</span><span>.</span><span>strokeStart</span> <span>=</span> <span>0.0</span> 
<span>shapeLayer</span><span>.</span><span>strokeEnd</span> <span>=</span> <span>0.0</span> 
 
<span>let</span> <span>strokeEndAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"strokeEnd"</span><span>)</span> 
<span>strokeEndAnimation</span><span>.</span><span>toValue</span> <span>=</span> <span>1.0</span> 
<span>strokeEndAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>0.75</span> 
<span>strokeEndAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionEaseInEaseOut</span><span>)</span> 
<span>strokeEndAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>strokeEndAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"strokeEndAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
Animating a shape layer's stroke end<p>Contrariwise, animating <code>strokeStart</code> from 0.0 to 1.0 is commonly used to “erase” a path:</p> 
 
<div><div><pre><code><span>shapeLayer</span><span>.</span><span>strokeStart</span> <span>=</span> <span>0.0</span> 
<span>shapeLayer</span><span>.</span><span>strokeEnd</span> <span>=</span> <span>1.0</span> 
 
<span>let</span> <span>strokeStartAnimation</span> <span>=</span> <span>CABasicAnimation</span><span>(</span><span>keyPath</span><span>:</span> <span>"strokeStart"</span><span>)</span> 
<span>strokeStartAnimation</span><span>.</span><span>toValue</span> <span>=</span> <span>1.0</span> 
<span>strokeStartAnimation</span><span>.</span><span>duration</span> <span>=</span> <span>0.75</span> 
<span>strokeStartAnimation</span><span>.</span><span>timingFunction</span> <span>=</span> <span>CAMediaTimingFunction</span><span>(</span><span>name</span><span>:</span> <span>kCAMediaTimingFunctionEaseInEaseOut</span><span>)</span> 
<span>strokeStartAnimation</span><span>.</span><span>repeatCount</span> <span>=</span> <span>.</span><span>greatestFiniteMagnitude</span> 
 
<span>shapeLayer</span><span>.</span><span>add</span><span>(</span><span>strokeStartAnimation</span><span>,</span> <span>forKey</span><span>:</span> <span>"strokeStartAnimation"</span><span>)</span> 
</code></pre></div>  </div> 
Animating a shape layer's stroke start<p>One thing to keep in mind is that both <code>strokeStart</code> and <code>strokeEnd</code> are clamped to the range [0.0, 1.0]. That is, you can’t use negative values to reverse the direction of a stroke animation. To do so, just reverse the path itself using <code>UIBezierPath</code>’s <code>reversing()</code> function.</p> 
 
<h1>Summary</h1> 
 
<p><code>CAShapeLayer</code> is a very powerful tool for creating rich, performant shapes with a variety of properties to animate. The utility of some—<code>miterLimit</code>—is questionable, while the absence of others—<code>lineCap</code>, <code>lineDashPattern</code>, and <code>lineJoin</code>—is a little disappointing. Still, especially given iOS 7’s ushered in era of flatter design, basic shapes adorn much of modern app UI design. Morphing shapes, changing stroke line widths, and animating stroke start and end points are great ways to create compelling visual effects, and GPU-compositing of shapes makes it fast to include many of them at once in your designs without affecting render performance too adversely.</p> 
 
<p>In the final part of this series on <code>CAShapeLayer</code>, we’ll look at some interesting combinations of the properties discussed in the past two posts to create some neat designs and animations.</p> 
 
<div> 
  <ol><li> 
      <p>It is possible to prevent main thread-bound drawing operations by performing them asynchronously on a background thread, but this can add overhead and synchronization complexity to complex drawings. Even still, each bitmap will have to be uploaded to Core Animation every frame in order to synchronize the animation with the main run loop. <a href="http://calayer.com/#fnref:1">↩</a></p> 
    </li> 
    <li> 
      <p>Most paths will want a redundant point to draw a line back to the beginning, which means you’ll always see an extra <code>CGPoint</code> in your path code. You can actually call <code>close()</code> on the path to automatically finish it without explicitly drawing a line to the beginning, it always draws a straight line between the last point moved to and the initial point, which may not be what you want. <a href="http://calayer.com/#fnref:2">↩</a></p> 
    </li> 
    <li> 
      <p>The rendered animation on the web actually looks different from how Core Animation renders the same animation, but the results are equally undesirable. <a href="http://calayer.com/#fnref:3">↩</a></p> 
    </li> 
    <li> 
      <p>In fact, based on my own observation, it appears that <code>CAShapeLayer</code> interpolates between points in the same order that they’re added to the path, and missing points are animated to/from (0, 0). So while you can probably reason what the incongruent path animation would look like, you shouldn’t rely on this behavior. <a href="http://calayer.com/#fnref:4">↩</a></p> 
    </li> 
    <li> 
      <p>One of the best solutions I’ve seen for this problem, albeit only for the web, is <a href="https://greensock.com/morphSVG">GreenSock’s MorphSVG plugin</a>. Regardless of the number of control points or segments, it create very impressive path animations. In my opinion, Core Animation desperately needs a comparable feature to make shape layers less frustrating to animate. <a href="http://calayer.com/#fnref:5">↩</a></p> 
    </li> 
    <li> 
      <p>My tool of choice is <a href="https://www.paintcodeapp.com">PaintCode</a>, which is a solid vector graphics and code generation app. My experiments with Adobe Illustrator were not very good, as it appears to export strange SVGs despite manually moving the same points around. <a href="http://calayer.com/#fnref:6">↩</a></p> 
    </li> 
    <li> 
      <p>A dash pattern with only one value would still produce a solid line, so Core Animation implicitly uses the same value for the unpainted segments. <a href="http://calayer.com/#fnref:7">↩</a></p> 
    </li> 
  </ol></div>
	</body>
</html>
