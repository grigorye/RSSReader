<?xml version="1.0" encoding="UTF-8"?>
<!doctype html>
<html>
	<head>
		<style type="text/css">
			h2 {
				font: -apple-system-headline;
			}
			body {
				font: -apple-system-body;
				zoom: 1.2;
			}
			img {
				width: auto;
				height : auto;
				max-height: 100%;
				max-width: 100%;
			}
		</style>
	</head>
	<body>
		<h2>Using Spots Framework for Cross-Platform Development</h2>
		<p><img src="https://koenig-media.raywenderlich.com/uploads/2018/01/Spots-feature.png" alt="" width="250" height="250"></p> 
<p>Spots is an open-source framework that enables you to design your UI for one platform, and use it on iOS, tvOS, and macOS. This lets you spend more time working on your app, and less time porting it to other platforms. Spots is also architected in such a way that it makes it incredibly easy to redesign your layout, by making use of the view model pattern. You can read more about what inspired the creators of Spots <a href="https://medium.com/@zenangst/hitting-the-sweet-spot-of-inspiration-637d387bc629">here</a>.</p> 
<h2>Getting Started</h2> 
<p>In this tutorial, you’ll start off by making a simple app for iOS and use Spots to help you port the app to tvOS and macOS. Start by downloading the <a href="https://koenig-media.raywenderlich.com/uploads/2017/11/Starter-Project.zip">starter project here</a>.</p> 
<p>The starter project includes Spots, which has been pre-installed via Cocoapods. If you’re curious to learn more, you can look inside the Podfile to see how it’s set up, or check out our <a href="https://www.raywenderlich.com/97014/use-cocoapods-with-swift">Cocoapods with Swift tutorial</a>. You’ll use the imported Spots framework later to port your UI to JSON.</p> 
<p>Open up <em>Dinopedia.xcworkspace</em>, and then open up the <em>Dinopedia-iOS</em> group. Then open up <em>Main.storyboard</em> within that group. You’ll notice that it contains an empty <code>UINavigationController</code>. Embedding <code>UIViewController</code>s in a <code>UINavigationController</code> facilitates navigation between the <code>UIViewController</code>s and makes it easy for you to set the <code>UIViewController</code>s’ titles. You will work with both these features within this tutorial.</p> 
<div><em>Note</em>: At the time this tutorial was written, Spots did not compile cleanly with Swift 4 so you will see a warning that conversion to Swift 4 is available. When you build, you will see a number of other warnings in the Spots libraries. You’ll just have to ignore them for now.</div> 
<h2>Creating Your First View</h2> 
<p>To build a user interface in <code>Spots</code>, you first have to instantiate a custom view. In Spots, you make a custom view by creating a new subclass of <code>UIView</code> that conforms to <code>ItemConfigurable</code>. Then, you set up your constraints and the size of your view.</p> 
<p>Create a new file inside the <em>Dinopedia-iOS</em> group named <em>CellView.swift</em> that inherits from <code>UIView</code>. At the top of the file, add the following code: </p> 
<pre>
 
import Spots
 
</pre> 
<p>Add the following code inside the <code>CellView</code> class:</p> 
<pre>
 
lazy var titleLabel = UILabel()
 
</pre> 
<p>You have now created a label that you will soon populate. By declaring the property as <code>lazy</code>, the label will be instantiated when it is first accessed. In this case, it means it will be instantiated when the label is actually going to be populated and displayed. Properties that are not declared as <code>lazy</code> are instantiated when the <code>class</code> or <code>struct</code> in which they are declared is instantiated.</p> 
<p>Below where you declared the <code>titleLabel</code>, add the following code:</p> 
<pre>
 
override init(frame: CGRect) {
 
  super.init(frame: frame)
 
  
 
  addSubview(titleLabel)
 
}
 
</pre> 
<p>This overrides the view’s initializer, and will initialize the view and add the label. </p> 
<p>Next, add the following required method below <code>init(frame:)</code>:</p> 
<pre>
 
required init?(coder aDecoder: NSCoder) {
 
  fatalError("init(coder:) has not been implemented")
 
}
 
</pre> 
<p>In Swift, a subclass does not inherit its superclass’s designated initializer(s) by default. Since <em>CellView.swift</em> inherits from <code>UIView</code>, you must override all <code>UIView</code>‘s designated initializers.</p> 
<p>Finally, you’ll implement three methods for configuring your view. First you will add constraints to the <code>titleLabel</code> you created earlier so that it displays nicely on the screen. Constraining the <code>titleLabel</code> is not enough; next you will need to populate the <code>titleLabel</code> with text.</p> 
<p>Add the following new method at the bottom of the class:</p> 
<pre>
 
func setupConstraints() {
 
   titleLabel.translatesAutoresizingMaskIntoConstraints = false
 
   titleLabel.centerYAnchor.constraint(equalTo: centerYAnchor).isActive = true
 
   titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16).isActive = true
 
   titleLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16).isActive = true
 
}
 
</pre> 
<p>These constraints position the label in the center of your view vertically and give it a width equal to that of your view, with a bit of padding on either side.</p> 
<p>At the bottom of <code>init(frame:)</code>, add the following code: </p> 
<pre>
 
setupConstraints()
 
</pre> 
<p>This will therefore add the constraints right when <code>CellView</code> is initialized.</p> 
<p>Now add the following to the bottom of the file, outside of the class definition:</p> 
<pre>
 
extension CellView: ItemConfigurable {
 
  
 
  func configure(with item: Item) {
 
    titleLabel.text = item.title
 
  }
 
  
 
  func computeSize(for item: Item) -&gt; CGSize {
 
    return CGSize(width: bounds.width, height: 80)
 
  }
 
  
 
}
 
</pre> 
<p><code>configure(with:)</code> sets the label’s text with the data passed as a parameter. <code>computeSize(for:)</code> sets the size of the view.</p> 
<p>Now it’s time to use your view. In order for the application to use your view, you’ll have to register it. Open <em>AppDelegate.swift</em> and add the following code: </p> 
<pre>
 
import Spots
 
</pre> 
<p>Then add the following to <code>application(didFinishLaunchingWithOptions)</code>, before the <code>return</code>:</p> 
<pre>
 
Configuration.register(view: CellView.self, identifier: "Cell")
 
</pre> 
<p>This registers the view you just created with the identifier <code>"Cell"</code>. This identifier lets you reference your view within the Spots framework.</p> 
<h2>Creating Your First ComponentModel</h2> 
<p>It’s time to work with the Spots framework. First, you will create a <code>ComponentModel</code>.</p> 
<p>Open <em>ViewController.swift</em> (make sure you choose the one in <em>Dinopedia-iOS</em>!). <code>Item</code>s make up your <code>ComponentModel</code> and contain the data for your application. This data will be what the user sees when running the app.</p> 
<p>There are many properties associated with <code>Item</code>s. For example:</p> 
<ul><li><code>title</code> is the name of the dinosaur’s species.</li> 
<li><code>kind</code> is the identifier that you gave <em>CellView.swift</em> in the <em>AppDelegate.swift</em> above.</li> 
<li><code>meta</code> has additional attributes, like the dinosaur’s scientific name and diet. You’ll use some of these properties now.</li> 
</ul><p>Add the following code at the top of the file:</p> 
<pre>
 
import Spots
 
</pre> 
<p>Add the following inside the <code>viewDidLoad()</code>, below <code>super.viewDidLoad()</code>.</p> 
<pre>
 
let model = ComponentModel(kind: .list, items: [
 
  Item(title: "Tyrannosaurus Rex", kind: "Cell", meta: [
 
    "ScientificName": "Tyrannosaurus Rex",
 
    "Speed": "12mph",
 
    "Lived": "Late Cretaceous Period",
 
    "Weight": "5 tons",
 
    "Diet": "Carnivore",
 
]),
 
  Item(title: "Triceratops", kind: "Cell", meta: [
 
    "ScientificName": "Triceratops",
 
    "Speed": "34mph",
 
    "Lived": "Late Cretaceous Period",
 
    "Weight": "5.5 tons",
 
    "Diet": "Herbivore",
 
]),
 
  Item(title: "Velociraptor", kind: "Cell", meta: [
 
    "ScientificName": "Velociraptor",
 
    "Speed": "40mph",
 
    "Lived": "Late Cretaceous Period",
 
    "Weight": "15 to 33lbs",
 
    "Diet": "Carnivore",
 
]),
 
  Item(title: "Stegosaurus", kind: "Cell", meta: [
 
    "ScientificName": "Stegosaurus Armatus",
 
    "Speed": "7mph",
 
    "Lived": "Late Jurassic Period",
 
    "Weight": "3.4 tons",
 
    "Diet": "Herbivore",
 
]),
 
  Item(title: "Spinosaurus", kind: "Cell", meta: [
 
    "ScientificName": "Spinosaurus",
 
    "Speed": "11mph",
 
    "Lived": "Cretaceous Period",
 
    "Weight": "7.5 to 23 tons",
 
    "Diet": "Fish",
 
]),
 
  Item(title: "Archaeopteryx", kind: "Cell", meta: [
 
    "ScientificName": "Archaeopteryx",
 
    "Speed": "4.5mph Running, 13.4mph Flying",
 
    "Lived": "Late Jurassic Period",
 
    "Weight": "1.8 to 2.2lbs",
 
    "Diet": "Carnivore",
 
]),
 
  Item(title: "Brachiosaurus", kind: "Cell", meta: [
 
    "ScientificName": "Brachiosaurus",
 
    "Speed": "10mph",
 
    "Lived": "Late Jurassic Period",
 
    "Weight": "60 tons",
 
    "Diet": "Herbivore",
 
]),
 
  Item(title: "Allosaurus", kind: "Cell", meta: [
 
    "ScientificName": "Allosaurus",
 
    "Speed": "19 to 34mph",
 
    "Lived": "Late Jurassic Period",
 
    "Weight": "2.5 tons",
 
    "Diet": "Carnivore",
 
]),
 
  Item(title: "Apatosaurus", kind: "Cell", meta: [
 
    "ScientificName": "Apatosaurus",
 
    "Speed": "12mph",
 
    "Lived": "Late Jurassic Period",
 
    "Weight": "24.5 tons",
 
    "Diet": "Herbivore",
 
]),
 
  Item(title: "Dilophosaurus", kind: "Cell", meta: [
 
    "ScientificName": "Dilophosaurus",
 
    "Speed": "20mph",
 
    "Lived": "Early Jurassic Period",
 
    "Weight": "880lbs",
 
    "Diet": "Carnivore",
 
  ]),
 
])
 
</pre> 
<p>The code here is fairly straightforward. At the top, you create a new <code>ComponentModel</code> of type <code>list</code>. This causes your view to render as a <code>UITableView</code> instance. Then, you create your array of <code>Item</code>s with a specific <code>title</code> and <code>kind</code>. This contains your data and sets its view type to the identifier, <code>"Cell"</code>, which you specified earlier in <em>AppDelegate.swift</em>.</p> 
<h2>Adding Your View to the Scene</h2> 
<p>To use your data, you’ll need to create a controller. Still inside <code>viewDidLoad()</code>, add the following below your model:</p> 
<pre>
 
let component = Component(model: model)
 
</pre> 
<p>The final steps to get your view on the screen are to create a <code>SpotsController</code> and add it to the screen, so let’s do that now. Still inside <code>viewDidLoad()</code>, add the following under your component:</p> 
<pre>
 
let controller = SpotsController(components: [component])
 
controller.title = "Dinopedia"
 
</pre> 
<p>This will create a new <code>SpotsController</code> and set its title, which the <code>UINavigationController</code> will use.</p> 
<p>Finally, add the controller to the <code>UINavigationController</code> with:</p> 
<pre>
 
setViewControllers([controller], animated: true)
 
</pre> 
<p>The code above sets the stack of the <code>UINavigationController</code>, which at this point consists of <code>SpotsController</code>. If you had more than one <code>UIViewController</code> that you wanted within the <code>UINavigationController</code>‘s stack, you would simply add it inside the <code>Array</code> that currently holds <code>[controller]</code>.</p> 
<p>Build and run to see your dinosaurs!</p> 
<p><a href="https://koenig-media.raywenderlich.com/uploads/2018/01/Simulator-Screen-Shot-iPhone-8-2018-01-04-at-16.07.27.png"><img src="https://koenig-media.raywenderlich.com/uploads/2018/01/Simulator-Screen-Shot-iPhone-8-2018-01-04-at-16.07.27-281x500.png" alt="dinosaur list at first run" width="281" height="500"></a></p> 
<h2>Responding to Taps on Dinosaurs</h2> 
<p>You’ll notice, however, that you can’t tap on the dinosaurs to see more information about them. To respond when the user taps a cell, you need to implement the <code>component(itemSelected:)</code> method of the <code>ComponentDelegate</code> protocol.</p> 
<p>Still in <code>ViewController.swift</code>, at the bottom of the file, make a new extension and implement the method by adding the following code:</p> 
<pre>
 
extension ViewController: ComponentDelegate {
 
  func component(_ component: Component, itemSelected item: Item) {
 

 
  }
 
}
 
</pre> 
<p>In the code above, your <code>ViewController</code> adopts <code>ComponentDelegate</code> so that it has the ability to respond when a user taps on a cell. Your <code>ViewController</code> conforms to <code>ComponentDelegate</code> by implementing the required method inside the extension.</p> 
<p>First, you’ll want to retrieve the information about each dinosaur. When you made the <code>ComponentModel</code>, you stored the information in the <code>meta</code> property. Inside the <code>component(itemSelected:)</code> method you just added, make a new <code>ComponentModel</code> by adding the following code:</p> 
<pre>
 
let itemMeta = item.meta
 

 
let newModel = ComponentModel(kind: .list, items: [
 
  Item(title: "Scientific Name: \(itemMeta["ScientificName"] as! String)", kind: "Cell"),
 
  Item(title: "Speed: \(itemMeta["Speed"] as! String)", kind: "Cell"),
 
  Item(title: "Lived: \(itemMeta["Lived"] as! String)", kind: "Cell"),
 
  Item(title: "Weight: \(itemMeta["Weight"] as! String)", kind: "Cell"),
 
  Item(title: "Diet: \(itemMeta["Diet"] as! String)", kind: "Cell")
 
])
 
</pre> 
<p>Here, you create a property <code>itemMeta</code> and set it to the <code>meta</code> property of the <code>item</code> which the user tapped. <code>itemMeta</code> is a <code>Dictionary</code> of <code>String</code> to <code>Any</code>. When creating <code>newModel</code>, you retrieve the value associated with each key in <code>itemMeta</code>. Like before, the <code>kind</code> parameter is the identifier of <em>CellView.swift</em> that you declared in the <code>AppDelegate</code>.</p> 
<p>Finally, add the following code underneath that which you just added:</p> 
<pre>
 
let newComponent = Component(model: newModel) //1
 
newComponent.tableView?.allowsSelection = false //2
 

 
let detailController = SpotsController() //3
 
detailController.components = [newComponent]
 
detailController.title = item.title
 
detailController.view.backgroundColor = UIColor.white
 

 
pushViewController(detailController, animated: true) //4
 
</pre> 
<p>This creates the <code>Component</code> and <code>SpotsController</code> and adds it to the scene. Breaking it down:</p> 
<ol><li>First you instantiate <code>newComponent</code>, which has a property called <code>tableView</code>.</li> 
<li>You disable selection on the <code>tableView</code>.</li> 
<li>Next you instantiate <code>detailController</code> and add <code>newComponent</code> to the <code>components</code> property on <code>detailController</code>.</li> 
<li>Finally, you push the new controller.</li> 
</ol><p>If you were to build and run now, nothing would happen when you click on the cells. This is because you haven’t set the <code>ViewController</code> as the <code>SpotsController</code>‘s delegate.</p> 
<p>Back inside <code>viewDidLoad()</code>, add the following where you defined the <code>SpotsController</code>:</p> 
<pre>
 
controller.delegate = self
 
</pre> 
<p>Build and run to see some more information about the dinosaurs in your app!</p> 
<p><a href="https://koenig-media.raywenderlich.com/uploads/2018/01/Simulator-Screen-Shot-iPhone-8-2018-01-04-at-16.29.23.png"><img src="https://koenig-media.raywenderlich.com/uploads/2018/01/Simulator-Screen-Shot-iPhone-8-2018-01-04-at-16.29.23-281x500.png" alt="dinosaur detail" width="281" height="500"></a></p> 
<h2>Converting to JSON</h2> 
<p>If you looked around in the project, you may have noticed the <em>dinopedia.json</em> file. Open it up and you’ll see that the JSON data looks very similar to the model you made. You’ll use this JSON file to port your app to tvOS and macOS. This is one of the selling points of Spots. You can create your controllers with simple JSON data. The idea being that you can move this JSON to come from your web server, making it very easy to create your views from data your server sends.</p> 
<p>First, you’ll change your iOS app to use JSON instead of manually creating the model.</p> 
<p>Open <em>ViewController.swift</em> and replace the contents of <code>viewDidLoad()</code> with the following:</p> 
<pre>
 
super.viewDidLoad()
 

 
guard let jsonPath = Bundle.main.path(forResource: "dinopedia", ofType: "json") else { //1
 
  print("JSON Path Not Found")
 
  return
 
}
 

 
let jsonURL = URL(fileURLWithPath: jsonPath)
 
do {
 
  let jsonData = try Data(contentsOf: jsonURL, options: .mappedIfSafe)
 
  let jsonResult = try JSONSerialization.jsonObject(with: jsonData, 
 
                                                    options: .mutableContainers) as! [String: Any] //2
 
  
 
  let controller = SpotsController(jsonResult) //3
 
  controller.delegate = self
 
  controller.title = "Dinopedia"
 
  
 
  setViewControllers([controller], animated: true) //4
 
} catch {
 
  print("Error Creating View from JSON")
 
}
 
</pre> 
<p>Here’s what you’re doing above:</p> 
<ol><li>First, you find the path of the JSON file and create a URL with it.</li> 
<li>Then you retrieve the data and parse it into a <code>Dictionary</code>.</li> 
<li>Next, you create a new <code>SpotsController</code>, passing in the JSON.</li> 
<li>Finally, you add it to the scene.</li> 
</ol><p>Build and run to see your app. It looks just as it did before, but now you’re using JSON!</p> 
<p><a href="https://koenig-media.raywenderlich.com/uploads/2018/01/Simulator-Screen-Shot-iPhone-8-2018-01-04-at-18.32.26.png"><img src="https://koenig-media.raywenderlich.com/uploads/2018/01/Simulator-Screen-Shot-iPhone-8-2018-01-04-at-18.32.26-281x500.png" alt="iOS views created from JSON" width="281" height="500"></a></p> 
<h2>Porting to tvOS</h2> 
<p>Now that you’ve spent time creating your app on iOS, it’s time to port to tvOS. Luckily, it’s very easy to port your app to tvOS using Spots. You’ll reuse all the code you wrote for iOS!  </p> 
<p>Add each Swift file from your iOS target to the tvOS target, including <em>AppDelegate.swift</em>, by checking the boxes in the File Inspector on the right-hand side of Xcode.</p> 
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/11/Screen-Shot-4-339x500.png" alt="" width="339" height="500"></p> 
<p>Inside the tvOS version of <em>Main.storyboard</em>, a <code>UINavigationController</code> has already been added for you. Since iOS and tvOS both use <code>UIKit</code>, you can conveniently share all of your files! Build and run the tvOS target to see your app beautifully ported to tvOS.</p> 
<p><a href="https://koenig-media.raywenderlich.com/uploads/2018/01/Simulator-Screen-Shot-Apple-TV-4K-at-1080p-2018-01-04-at-18.47.26.png"><img src="https://koenig-media.raywenderlich.com/uploads/2018/01/Simulator-Screen-Shot-Apple-TV-4K-at-1080p-2018-01-04-at-18.47.26-650x366.png" alt="dinopedia on tvOS" width="650" height="366"></a></p> 
<h2>Porting to macOS</h2> 
<p>Unfortunately, macOS doesn’t use <code>UIKit</code> and takes a little more work to port. You can’t just reuse files like you did for tvOS. But you’ll reuse most of the code, with only a few minor changes here and there. </p> 
<p>Inside the macOS target, open up <em>Main.storyboard</em>. A stack view is already set up for you. It contains a view on the left and right with a divider in the middle. Both views have outlets already made and wired up to <em>ViewController.swift</em>.</p> 
<p>Now right click on the <em>Dinopedia-macOS</em> group and select <em>New File…</em>. Then select <em>macOS\Cocoa Class</em> and click <em>Next</em>. Name the class <em>CellView</em> with a subclass of <code>NSView</code>, and click <em>Next</em>. Then save it in the default location, making sure that the <em>Dinopedia-macOS</em> target is selected.</p> 
<p>Now remove the call to <code>draw()</code> and add the following code to the top of the file: </p> 
<pre>
 
import Spots
 
</pre> 
<p>Inside <code>CellView</code>, define a new <code>NSTextField</code> called <code>titleLabel</code>:</p> 
<pre>
 
lazy var titleLabel = NSTextField()
 
</pre> 
<p>Implement the required methods for <code>Spots</code>:</p> 
<pre>
 
override init(frame frameRect: NSRect) {
 
  super.init(frame: frameRect)
 
  
 
  addSubview(titleLabel)
 
}
 

 
required init?(coder decoder: NSCoder) {
 
  super.init(coder: decoder)
 
}
 
</pre> 
<p>As with the implementation of iOS Dinopedia’s <code>CellView</code>, here the macOS <code>CellView</code> must override <code>NSView</code>‘s designated initializer.</p> 
<p>Now, create the <code>setupConstraints()</code> method to set up the <code>titleLabel</code>:</p> 
<pre>
 
func setupConstraints() {
 
  titleLabel.translatesAutoresizingMaskIntoConstraints = false
 
  NSLayoutConstraint.activate([
 
    titleLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
 
    titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
 
    titleLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
 
    ])
 
}
 
</pre> 
<p>Here you are constraining <code>titleLabel</code> so that it is centered vertically within its super view and so that it has a slight margin of 16 points on either side relative to its super view. </p> 
<p>Now add the following code at the end of <code>init(frame:)</code>:</p> 
<pre>
 
setupConstraints()
 
</pre> 
<p>This ensures that <code>setupConstraints()</code> is called when <code>CellView</code> is initialized.</p> 
<p>Finally, create a new extension at the bottom of the file to set up the size of the view:</p> 
<pre>
 
extension CellView: ItemConfigurable {
 
  
 
  func configure(with item: Item) {
 
    titleLabel.stringValue = item.title
 
    titleLabel.isEditable = false
 
    titleLabel.isSelectable = false
 
    titleLabel.isBezeled = false
 
    titleLabel.drawsBackground = false
 
  }
 
  
 
  func computeSize(for item: Item) -&gt; CGSize {
 
    return CGSize(width: item.size.width, height: 80)
 
  }
 

 
}
 
</pre> 
<p>Here you give the <code>titleLabel</code> some text and set certain properties on the <code>NSTextField</code>. You also create a method that returns the size of the item.</p> 
<p>The last step in setting up your view is to register it in the <code>AppDelegate</code>. Switch to <em>AppDelegate.swift</em> (the one inside <em>Dinopedia-macOS</em>) and add the following code to the top of the file: </p> 
<pre>
 
import Spots
 
</pre> 
<p>Add the following inside the <code>AppDelegate</code>:</p> 
<pre>
 
override func awakeFromNib() {
 
  super.awakeFromNib()
 
  Configuration.register(view: CellView.self, identifier: "Cell")
 
}
 
</pre> 
<p>Just like you did with registering <code>CellView.swift</code>‘s identifier in the <em>AppDelegate.swift</em> for the iOS and tvOS targets, you are performing a similar action above. However, since you use the view in a storyboard, you need register the view in <code>awakeFromNib()</code>.</p> 
<p>Now it’s time to set up your <code>ViewController</code>. Open up <em>ViewController.swift</em> (again, the one in <em>Dinopedia-macOS</em>) and add the following code to the top of the file: </p> 
<pre>
 
import Spots
 
</pre> 
<p>Add the following code to the end of <code>viewDidLoad()</code>:</p> 
<pre>
 
guard let jsonPath = Bundle.main.path(forResource: "dinopedia", ofType: "json") else { //1
 
  print("JSON Path Not Found")
 
  return
 
}
 

 
let jsonURL = URL(fileURLWithPath: jsonPath)
 
do {
 
  let jsonData = try Data(contentsOf: jsonURL, options: .mappedIfSafe)
 
  let jsonResult = try JSONSerialization.jsonObject(with: jsonData, 
 
                                                   options: .mutableContainers) as! [String: Any] //2
 
      
 
  let controller = SpotsController(jsonResult) //3
 
  controller.title = "Dinopedia" //4
 
      
 
  addChildViewController(controller) //5
 
  leftView.addSubview(controller.view)
 
  controller.view.translatesAutoresizingMaskIntoConstraints = false
 
  NSLayoutConstraint.activate([
 
    controller.view.leadingAnchor.constraint(equalTo: leftView.leadingAnchor, constant: 0),
 
    controller.view.trailingAnchor.constraint(equalTo: leftView.trailingAnchor, constant: 0),
 
    controller.view.topAnchor.constraint(equalTo: leftView.topAnchor, constant: 0),
 
    controller.view.bottomAnchor.constraint(equalTo: leftView.bottomAnchor, constant: 0)
 
    ])
 
} catch {
 
  print("Error Creating View from JSON")
 
}
 
</pre> 
<p>There’s a lot going on there, but it’s relatively straightforward:</p> 
<ol><li>First you find the path to the <em>dinopedia.json</em> file.</li> 
<li>You then retrieve that data and deserialize it into a <code>Dictionary</code>.</li> 
<li>Next you instantiate a new <code>SpotsController</code>.</li> 
<li>You subsequently set the <code>UINavigationController</code>‘s title.</li> 
<li>Finally, you add the <code>SpotsController</code> as a <em>childViewController</em> of <code>ViewController</code> and constrain it within <code>ViewController</code>.</li> 
</ol><p>You’ll notice that this is the same code used for iOS, but you add constraints to the <code>SpotsController</code> and add it to the <code>leftView</code>. You add constraints to the view to make sure it fills the entire view.</p> 
<p>Create a new extension at the bottom of the file and implement <code>ComponentDelegate</code>:</p> 
<pre>
 
extension ViewController: ComponentDelegate {
 
  func component(_ component: Component, itemSelected item: Item) {
 

 
  }
 
}
 
</pre> 
<p>Here you are adopting and conforming to <code>ComponentDelegate</code> so that <code>ViewController</code> responds when the user clicks a cell.</p> 
<p>You can repeat the same code used to retrieve the data, so add the following to <code>component(itemSelected:)</code>:</p> 
<pre>
 
let itemMeta = item.meta
 

 
let newModel = ComponentModel(kind: .list, items: [
 
  Item(title: "Scientific Name: \(itemMeta["ScientificName"] as! String)", kind: "Cell"),
 
  Item(title: "Speed: \(itemMeta["Speed"] as! String)", kind: "Cell"),
 
  Item(title: "Lived: \(itemMeta["Lived"] as! String)", kind: "Cell"),
 
  Item(title: "Weight: \(itemMeta["Weight"] as! String)", kind: "Cell"),
 
  Item(title: "Diet: \(itemMeta["Diet"] as! String)", kind: "Cell"),
 
  ])
 
let newComponent = Component(model: newModel)
 
</pre> 
<p>You’ll need to remove the <code>SpotsController</code> on the righthand pane and replace it with a new <code>SpotsController</code> whenever the user selects a new dinosaur. To do this you check if a <code>SpotsController</code> has been added to the right, and remove it if it has. Then you can add a new <code>SpotsController</code> to the right.</p> 
<p>Add the following to the end of <code>component(itemSelected:)</code>:</p> 
<pre>
 
if childViewControllers.count &gt; 1 {
 
  childViewControllers.removeLast()
 
  rightView.subviews.removeAll()
 
}
 
</pre> 
<p>In this code, you determine if there is more than one view controller in <code>childViewControllers</code>. This check is important to make sure that <code>childViewControllers.removeLast()</code> can be successfully executed. If <code>childViewControllers.removeLast()</code> is called and there is not at least one <code>childViewControllers</code>, then the app would crash because <code>childViewControllers.removeLast()</code> would be trying to remove something that does not exist. You subsequently remove all the subviews on <code>rightView</code> since these subviews will be replaced with the user’s new dinosaur selection.</p> 
<p>Now that you have a clear space to add your new <code>SpotsController</code>, add the following to the end of <code>component(itemSelected:)</code>:</p> 
<pre>
 
let detailController = SpotsController()
 
detailController.components = [newComponent]
 
detailController.title = item.title
 

 
addChildViewController(detailController)
 
rightView.addSubview(detailController.view)
 
detailController.view.translatesAutoresizingMaskIntoConstraints = false
 
NSLayoutConstraint.activate([
 
  detailController.view.leadingAnchor.constraint(equalTo: rightView.leadingAnchor, constant: 0),
 
  detailController.view.trailingAnchor.constraint(equalTo: rightView.trailingAnchor, constant: 0),
 
  detailController.view.topAnchor.constraint(equalTo: rightView.topAnchor, constant: 0),
 
  detailController.view.bottomAnchor.constraint(equalTo: rightView.bottomAnchor, constant: 0)
 
  ])
 
</pre> 
<p>Again, this repeats from iOS, but adds constraints to the new view to fill the space.</p> 
<p>Now that <code>SpotsController</code> conforms to <code>ComponentDelegate</code>, it’s time to set <code>SpotsController</code> as the delegate. Back inside <code>viewDidLoad()</code>, add the following where you defined the <code>SpotsController</code>:</p> 
<pre>
 
controller.delegate = self
 
</pre> 
<p>Before you build and run your macOS application, go to the macOS <em>Project Editor</em> and make sure you have a development team selected:</p> 
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/12/Project-Editor-4-650x230.png" alt="" width="650" height="230"></p> 
<p>If a development team is not available, you may have to set up your macOS credentials. This <a href="https://doc.owncloud.org/branded_clients/branded_ios_app/publishing_ios_app_2.html">Create Certificate Signing Request Tutorial</a> is a helpful resource if you are unsure how to set up your credentials.</p> 
<p>Now it is time to build and run to see your finished application running on macOS!</p> 
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/11/Screen-Shot-6-650x455.png" alt="" width="650" height="455"></p> 
<h2>Where To Go From Here?</h2> 
<p>Well, that was a whirlwind tour of Spots! You’ve seen how you can build a simple UI using the framework, and port it from iOS to tvOS and macOS. Hopefully you can see how this could be useful. When the UI gets even more complex, this ease of porting becomes very useful. You’ve also seen how Spots uses the view model concept through its “controllers”, and how these can easily be created from JSON data.</p> 
<p>Here’s the <a href="https://koenig-media.raywenderlich.com/uploads/2018/01/Final-Project.zip">Final Project</a> for this tutorial.</p> 
<p>To learn more about Spots, you can check out the <a href="https://github.com/hyperoslo/Spots/tree/master/Documentation">documentation</a> as well as the <a href="https://github.com/hyperoslo/Spots/blob/master/Documentation/Getting%20started%20guide.md">getting started guide</a> on Spots’ GitHub page.</p> 
<p>If you have any questions feel free to join the discussion below!</p> 
<p>The post <a href="https://www.raywenderlich.com/179043/using-spots-framework-for-cross-platform-development">Using Spots Framework for Cross-Platform Development</a> appeared first on <a href="https://www.raywenderlich.com">Ray Wenderlich</a>.</p>
	</body>
</html>
